# Mysql5.7主从

## 一、搭建主从

### 1 环境准备

- 主服务器 (Master): 10.50.10.3
- 从服务器 (Slave): 10.50.10.6
- 操作系统: CentOS 7.x
- MySQL版本: 5.7

### 2 主服务器(Master)配置

1 修改配置文件

```
[root@localhost ~]# vi /etc/my.cnf
```

在 `[mysqld]` 部分添加以下内容：

```
[mysqld]
server-id = 1                   # 服务器唯一标识，主从不能相同
log_bin = mysql-bin             # 开启二进制日志
binlog_format = ROW             # 使用行格式复制
expire_logs_days = 10           # 二进制日志保留天数
max_binlog_size = 100M          # 单个二进制日志文件最大大小
# binlog_do_db = your_database    # 可选，指定要复制的数据库
# 如果要从所有数据库复制，则不需要binlog_do_db参数
```

2  重启MySQL服务

```
[root@localhost ~]# systemctl restart mysqld
```

3 创建复制用户并授权

```
[root@localhost ~]# mysql -u root -p

-- 创建专门用于复制的用户，'%'表示允许从任何主机连接
CREATE USER 'repl'@'%' IDENTIFIED BY '123456';

-- 授予复制权限，这个用户只能用于复制，不能执行其他操作
GRANT REPLICATION SLAVE ON *.* TO 'repl'@'%';

-- 刷新权限使更改立即生效
FLUSH PRIVILEGES;
```

4 锁定表并获取二进制日志位置

```
-- 锁定所有表为只读状态，确保在备份期间没有数据变化
mysql> FLUSH TABLES WITH READ LOCK;

-- 查看当前二进制日志状态，记录File和Position值
-- 这些值将用于从服务器定位复制起始点
mysql> SHOW MASTER STATUS;
```

### 3 从服务器(Slave)配置

1 修改配置文件

```
[root@localhost ~]# vi /etc/my.cnf
```

在 `[mysqld]` 部分添加以下内容：

```
[mysqld]
server-id = 2                   # 从服务器唯一ID，必须与主服务器不同
relay_log = mysql-relay-bin     # 中继日志文件名
log_bin = mysql-bin             # 开启二进制日志（可选）
binlog_format = ROW             # 使用行格式复制
read_only = 1                   # 设置从服务器为只读模式
super_read_only = 1            # 超级用户也只读（MySQL 5.7.8+）
# replicate_do_db = app_db       # 指定复制哪些库
```

> super_read_only 若不设为 root 用户只读，使用root修改数据后会导致主从失败。解决方案如下 三

2 修改配置文件后重启

```
[root@localhost ~]# systemctl restart mysqld  # 重启MySQL使配置生效
```

3 配置复制连接

```
[root@localhost ~]# mysql -u root -p



-- 配置从服务器连接到主服务器的参数
CHANGE MASTER TO
MASTER_HOST='10.50.10.3',      -- 主服务器IP地址
MASTER_USER='repl',               -- 复制用户名
MASTER_PASSWORD='123456', -- 复制用户密码
MASTER_LOG_FILE='mysql-bin.000003', -- 主服务器SHOW MASTER STATUS中的File值
MASTER_LOG_POS=7808;                -- 主服务器SHOW MASTER STATUS中的Position值
```

4  启动复制并检查状态

```
-- 启动从服务器复制进程
mysql> START SLAVE;

-- 查看从服务器复制状态，\G表示垂直显示结果便于阅读
mysql> SHOW SLAVE STATUS\G
```

- `Slave_IO_Running: Yes` (I/O线程状态)
- `Slave_SQL_Running: Yes` (SQL线程状态)
- `Seconds_Behind_Master: 0` (复制延迟)
- `Read_Master_Log_Pos` (已读取的主库位置)

### 4 解锁主服务器表

返回主服务器的MySQL会话，执行：

```
-- 释放之前设置的表锁，允许主服务器继续正常写入
mysql> UNLOCK TABLES;
```

### 5 验证复制

1 在主服务器上创建测试数据

```
-- 创建测试数据库
CREATE DATABASE test_repl;

-- 使用测试数据库
-- USE test_repl;

-- 创建测试表
CREATE TABLE test_repl.test_table (
    id INT,             -- 整数类型ID字段
    name VARCHAR(20)    -- 最大20字符的字符串字段
);

-- 插入测试数据
INSERT INTO test_repl.test_table VALUES (1, 'test');
UPDATE test_repl.test_table SET name = 'mk666' WHERE id = 1;
```

2 在从服务器上检查数据

```
-- 查询测试表中的数据，验证是否已复制
SELECT * FROM test_repl.test_table;
```

### 6 防火墙配置（如有需要）

```
# 永久开放MySQL默认端口3306
sudo firewall-cmd --zone=public --add-port=3306/tcp --permanent

# 重新加载防火墙配置使更改生效
sudo firewall-cmd --reload
```

### 7 关键SQL语句功能详解

```
    CREATE USER

        创建专门用于复制的数据库用户

        'repl'@'%'表示用户名为repl，可以从任何主机连接

        IDENTIFIED BY设置用户密码

    GRANT REPLICATION SLAVE

        只授予复制所需的最小权限

        不同于普通数据库用户，复制用户只需要复制权限

    FLUSH TABLES WITH READ LOCK

        锁定所有表为只读状态

        确保获取二进制日志位置时没有新的写入

        重要：必须在同一个会话中执行SHOW MASTER STATUS

    SHOW MASTER STATUS

        显示当前二进制日志文件名称和位置

        从服务器需要这些信息知道从何处开始复制

    CHANGE MASTER TO

        配置从服务器与主服务器的连接参数

        包括主服务器地址、凭证和开始复制的位置

    START SLAVE

        启动从服务器的复制进程

        会启动两个线程：I/O线程和SQL线程

    SHOW SLAVE STATUS

        查看从服务器复制状态和统计信息

        最重要的监控命令之一

    UNLOCK TABLES

        释放主服务器上的表锁

        允许主服务器继续正常处理写入操作
```

### 8 维护建议（如有需要）

1 定期检查复制状态：

```
SHOW SLAVE STATUS\G
```

2 如遇错误需要跳过：

```
STOP SLAVE;                        -- 停止复制
SET GLOBAL SQL_SLAVE_SKIP_COUNTER=1; -- 跳过1个错误事件
START SLAVE;                       -- 重新启动复制
```

3 完全重置复制（谨慎使用）：

```
STOP SLAVE;
RESET SLAVE ALL;  -- 清除所有复制配置信息
```





## 二、移除主从

### 1 停止从服务器复制进程

```
[root@localhost ~]# mysql -u root -p

-- 停止从服务器的I/O和SQL线程
mysql> STOP SLAVE;

-- 重置所有复制配置信息
-- ALL参数会清除所有复制配置，包括连接信息和relay log
mysql> RESET SLAVE ALL;
```

- `STOP SLAVE` 停止复制进程，但保留配置信息
- `RESET SLAVE ALL` 完全清除复制配置，比单纯的`RESET SLAVE`更彻底

### 2 移除主服务器复制配置

```
[root@localhost ~]# mysql -u root -p

-- 删除专门为复制创建的用户  repl指User字段，%指Host字段
mysql> DROP USER 'repl'@'%';

-- 刷新权限使更改立即生效
mysql> FLUSH PRIVILEGES;
```

- `DROP USER` 删除不再需要的复制用户，增强安全性
- `FLUSH PRIVILEGES` 确保权限变更立即生效

### 3 修改配置文件

1 主服务器配置还原

```
[root@localhost ~]# vi /etc/my.cnf


删除以下配置：

#server-id = 1
#log_bin = mysql-bin
#binlog_format = ROW
#expire_logs_days = 10
#max_binlog_size = 100M
#binlog_do_db = your_database_name
```

2 从服务器配置还原

```
[root@localhost ~]# vi /etc/my.cnf


删除以下配置：

#server-id = 2
#relay_log = mysql-relay-bin
#log_bin = mysql-bin
#binlog_format = ROW
#read_only = 1
```

### 4 重启MySQL服务

主、从服务器

```
# 重启MySQL服务使配置更改生效
[root@localhost ~]# systemctl restart mysqld

# 检查MySQL状态
[root@localhost ~]# systemctl status mysqld
```

- 重启服务使配置更改生效
- 检查状态确认服务正常运行

### 5 清理残留文件

在从服务器上执行

```
[root@localhost ~]#  rm -f /usr/local/mysql/data/mysql-relay-bin.*


# 删除master.info和relay-log.info文件
sudo rm -f /var/lib/mysql/master.info
sudo rm -f /var/lib/mysql/relay-log.info
```

- 这些是复制过程中生成的临时文件
- 清除它们确保完全干净的移除复制配置

### 6 验证移除结果

1 在从服务器上验证

```
[root@localhost ~]# mysql -u root -p


-- 检查是否还有复制配置
mysql> SHOW SLAVE STATUS\G

-- 预期结果：Empty set (0.00 sec)
```

2 在主服务器上验证

```
[root@localhost ~]# mysql -u root -p


-- 检查复制用户是否已删除
SELECT user,host FROM mysql.user WHERE user='repl';

-- 预期结果：Empty set (0.00 sec)
```



## 三、故障处理

常见：

- **1062错误**：主键冲突（从库已存在相同主键记录）
- **1032错误**：记录不存在（从库缺少主库存在的记录）
- **1593错误**：主从服务器ID冲突
- **1236错误**：二进制日志问题

### 1062错误

生成错误过程

```sql
-- 条件 id=2 在主从中都没有，执行一下产生错误
-- 从库
INSERT INTO test_repl.test_table VALUE (2,'slave');
-- 主库
INSERT INTO test_repl.test_table VALUE (2,'master');
-- 从库
SHOW SLAVE STATUS\G
```

> 报错详情：
>
> Last_Errno: 1062
> Last_Error: Could not execute Write_rows event on table test_repl.test_table; Duplicate entry '2' for key 'PRIMARY', Error_code: 1062; handler error HA_ERR_FOUND_DUPP_KEY; the event's master log mysql-bin.000003, end_log_pos 12701
>
> Last_SQL_Errno: 1062
> Last_SQL_Error: Could not execute Write_rows event on table test_repl.test_table; Duplicate entry '2' for key 'PRIMARY', Error_code: 1062; handler error HA_ERR_FOUND_DUPP_KEY; the event's master log mysql-bin.000003, end_log_pos 12701

从库

```sql
-- 1. 查看冲突数据
SELECT * FROM test_repl.test_table WHERE id=2;

-- 2. 临时停止复制
STOP SLAVE;

-- 3. 处理方案选择：
-- 删除从库冲突记录
DELETE FROM test_repl.test_table WHERE id=2;
-- 查主库，将数据重新插入从库
INSERT INTO test_repl.test_table VALUE (2,'master');
-- 保留从库数据，跳过此事件
SET GLOBAL SQL_SLAVE_SKIP_COUNTER=1;

-- 4. 重新启动复制
START SLAVE;
```

### 1032错误

生成错误过程

```sql
-- 条件 id=2 在主从中都没有，执行一下产生错误
-- 主库
INSERT INTO test_repl.test_table VALUE (2,'master');
-- 从库
DELETE FROM test_repl.test_table WHERE id=2;
-- 主库
UPDATE test_repl.test_table SET `name` = 'master01' WHERE id = 2;
-- 从库
SHOW SLAVE STATUS\G
```

> Last_Errno: 1032
> Last_Error: Could not execute Update_rows event on table test_repl.test_table; Can't find record in 'test_table', Error_code: 1032; handler error HA_ERR_KEY_NOT_FOUND; the event's master log mysql-bin.000003, end_log_pos 16902
>
> Last_SQL_Errno: 1032
> Last_SQL_Error: Could not execute Update_rows event on table test_repl.test_table; Can't find record in 'test_table', Error_code: 1032; handler error HA_ERR_KEY_NOT_FOUND; the event's master log mysql-bin.000003, end_log_pos 16902

```sql
-- 1. 查看 主库 数据
SELECT * FROM test_repl.test_table WHERE id=2;

-- 2. 从库 临时停止复制
STOP SLAVE;

-- 3. 处理方案选择：
-- 查 主库 ，将数据重新插入 从库
INSERT INTO test_repl.test_table VALUE (2,'master01');
-- 保留从库数据，跳过此事件
SET GLOBAL SQL_SLAVE_SKIP_COUNTER=1;

-- 4. 重新启动复制
START SLAVE;
```



### 严重不一致需重建复制

生成错误过程

```sql
-- 条件：主库表中无数据
-- 主库
TRUNCATE test_repl.test_table;

-- 从库
INSERT INTO test_repl.test_table VALUE (1,'slave01');

-- 主库
INSERT INTO test_repl.test_table VALUE (1,'master01');

-- 从库
SHOW SLAVE STATUS\G
```

**方法1：基于当前位置修复**

```sql
-- 1. 主库
mysql> FLUSH TABLES WITH READ LOCK;
mysql> SHOW MASTER STATUS; -- 记录File和Position

-- 2. 从库
mysql> STOP SLAVE;
mysql> RESET SLAVE;
mysql> CHANGE MASTER TO
  MASTER_LOG_FILE='mysql-bin.000003',
  MASTER_LOG_POS=19612;
mysql> START SLAVE;

-- 3. 主库
mysql> UNLOCK TABLES;
```

> 缺点：从库的数据不会主动更新为主库数据，需要主库更新后从库才会更新。
>
> 可以先将指定的错误表从主库导出，并导入到从库中。
>
> ```sql
> -- 1. 主库
> mysql> FLUSH TABLES WITH READ LOCK;
> mysql> SHOW MASTER STATUS; -- 记录File和Position
> [root@localhost ~]# mysqldump -uroot -p test_repl test_table > test_table_bak.sql
> 
> -- 2. 从库
> mysql> STOP SLAVE;
> mysql> RESET SLAVE;
> mysql> CHANGE MASTER TO
>   MASTER_LOG_FILE='mysql-bin.000003',
>   MASTER_LOG_POS=20341;
> [root@localhost ~]# mysql -uroot -p test_repl < test_table_bak.sql
> mysql> START SLAVE;
> 
> -- 3. 主库
> mysql> UNLOCK TABLES;
> ```



## 四、监控

### 1 邮件报警

从库同步异常时报警

安转mail

```
[root@localhost bin]# /usr/local/bin

[root@localhost bin]# yum install -y mailx

[root@localhost bin]# yum install -y sendmail
[root@localhost bin]# systemctl start sendmail
[root@localhost bin]# systemctl enable sendmail
```

脚本（mysql_slave_health.sh）

```bash
#!/bin/bash

# 配置数据库连接
USER="root"
PASS="123456"
HOST="10.50.10.6"

# 获取复制状态
STATUS=$(mysql -h $HOST -u $USER -p$PASS -e "SHOW SLAVE STATUS\G")

# 提取关键指标
IO_RUNNING=$(echo "$STATUS" | grep "Slave_IO_Running" | awk '{print $2}')
SQL_RUNNING=$(echo "$STATUS" | grep -w "Slave_SQL_Running" | awk '{print $2}')
SEC_BEHIND=$(echo "$STATUS" | grep "Seconds_Behind_Master" | awk '{print $2}')
LAST_ERRNO=$(echo "$STATUS" | grep "Last_Errno" | awk '{print $2}')
LAST_SQL_ERROR=$(echo "$STATUS" | grep "Last_SQL_Error" | awk '{print substr($0,index($0, $2))}')

# 检查状态并报警
if [ "$IO_RUNNING" != "Yes" ] || [ "$SQL_RUNNING" != "Yes" ] || [ "$SEC_BEHIND" -gt 60 ]; then
    #echo "CRITICAL: MySQL replication problem!"
    #echo "IO Running: $IO_RUNNING"
    echo "SQL Running: $SQL_RUNNING"
    #echo "Seconds Behind: $SEC_BEHIND"
    #echo "Last_Errno: $LAST_ERRNO"
    # echo "Last_SQL_Error: $LAST_SQL_ERROR"
    # 发送邮件通知
    echo "
CRITICAL: MySQL replication problem!

IO Running: $IO_RUNNING
SQL Running: $SQL_RUNNING
Seconds Behind: $SEC_BEHIND

Last_Errno: $LAST_ERRNO
Last_SQL_Error: $LAST_SQL_ERROR

MySQL slave synchronous alert on $(hostname)" | mail -s "MySQL Slave Alert" makun5201@163.com
    exit 1
else
    echo "OK: Replication is running normally"
    exit 0
fi

```

脚本权限

```
[root@localhost bin]# chmod +x mysql_slave_health.sh
```

定时任务

```
# 1. 检查 cron 服务状态
[root@localhost bin]# systemctl status crond.service
# 2. 启动 cron 服务
[root@localhost bin]# systemctl start crond.service
# 3. 设置开机自启
[root@localhost bin]# systemctl enable crond.service
```

Crontab 基本用法

```
1. 编辑当前用户的 cron 任务
[root@localhost bin]# crontab -e

# 每5分
*/5 * * * * /usr/local/bin/mysql_slave_health.sh


2. 查看当前用户的 cron 任务
[root@localhost bin]# crontab -l
3. 删除当前用户的所有 cron 任务
[root@localhost bin]# crontab -r
```



