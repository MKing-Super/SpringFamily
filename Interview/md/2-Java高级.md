# Java高级

## 二、Java高级篇

### 1、HashMap底层源码 

​		HashMap的底层结构在jdk1.7中由数组+链表实现，在jdk1.8中由数组+链表+红黑树实现。

​		HashMap基于哈希表的Map接口实现，是以key-value存储形式存在，即主要用来存放键值对。HashMap 的实现不是同步的，这意味着它不是线程安全的。它的key、value都可以为null。此外，HashMap中的映射不是有序的。

​		JDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突(两个对象调用的hashCode方法计算的哈希码值一致导致计算的数组索引值相同)而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（或者红黑树的边界值，默认为 8）并且当前数组的长度大于64时，此时此索引位置上的所有数据改为使用红黑树存储。

补充：

​		将链表转换成红黑树前会判断，即使阈值大于8，但是数组长度小于64，此时并不会将链表变为红黑树。而是选择进行数组扩容。

​		这样做的目的是因为数组比较小，尽量避开红黑树结构，这种情况下变为红黑树结构，反而会降低效率，因为红黑树需要进行左旋，右旋，变色这些操作来保持平衡 。同时数组长度小于64时，搜索时间相对要快些。所以综上所述为了提高性能和减少搜索时间，底层在阈值大于8并且数组长度大于64时，链表才转换为红黑树。具体可以参考 treeifyBin方法。

​		当然虽然增了红黑树作为底层数据结构，结构变得复杂了，但是阈值大于8并且数组长度大于64时，链表转换为红黑树时，效率也变的更高效。


### 2、JVM的分区与作用

​		JVM的运行时数据区（Runtime Data Areas）是Java虚拟机在执行Java程序时会把它所管理的内存划分为若干不同的区域。这些区域各有用途，有着不同的创建和销毁时间。

简易：

![](E:/MK/SpringFamily/Interview/md/images/b_02-1.png)

**一、核心内存分区与作用**

**1. 程序计数器（Program Counter Register）**

- •**作用**：**当前线程所执行的字节码的行号指示器**。它可以看作是线程的“执行进度条”，告诉线程下一步要执行哪条指令。
- •**特点**： •**线程私有**：每个线程都有自己独立的程序计数器，互不干扰。 •**不会内存溢出（OOM）**：这是唯一一个在Java虚拟机规范中没有规定任何`OutOfMemoryError`情况的区域。 •如果线程正在执行Java方法，计数器记录的是正在执行的虚拟机字节码指令地址；如果正在执行的是本地（Native）方法，则计数器值为空（`undefined`）。

**2. Java虚拟机栈（JVM Stack）**

- •**作用**：描述Java**方法执行的内存模型**。每个方法在执行的同时都会创建一个**栈帧（Stack Frame）**，用于存储**局部变量表**、**操作数栈**、**动态链接**、**方法出口**等信息。方法的调用和完成，对应着栈帧在虚拟机栈中的入栈和出栈过程。
- •**特点**： •**线程私有**，生命周期与线程相同。 •我们通常说的“栈内存”就是指它。 •如果线程请求的栈深度大于虚拟机所允许的深度（例如无限递归），将抛出`StackOverflowError`异常。 •如果栈可以动态扩展（大部分虚拟机都可以），但无法申请到足够内存时，会抛出`OutOfMemoryError`异常。
- •**重要概念：栈帧（Stack Frame）** •**局部变量表**：存放了编译期可知的各种基本数据类型（`boolean`, `byte`, `char`, `short`, `int`, `float`, `long`, `double`）、对象引用（`reference`类型）和返回地址（`returnAddress`类型）。 •**操作数栈**：用于执行字节码指令的工作区，就像CPU的寄存器。

**3. 本地方法栈（Native Method Stack）**

- •**作用**：与虚拟机栈非常相似，区别在于**虚拟机栈为执行Java方法服务，而本地方法栈则为虚拟机使用到的本地（Native）方法服务**（如用C/C++编写的方法）。
- •**特点**：HotSpot虚拟机等很多JVM实现选择将虚拟机栈和本地方法栈合二为一。

**4. 堆（Heap）**

- •**作用**：**存放对象实例和数组**。几乎所有通过`new`关键字创建的对象实例和数组都在这里分配内存。这是JVM管理中最大、最重要的一块区域，是**垃圾收集器（Garbage Collector, GC）管理的主要区域**，因此也被称作“GC堆”。
- •**特点**： •**线程共享**，因此存在线程安全问题。 •在虚拟机启动时创建。 •物理上可以是不连续的内存空间，只要逻辑上是连续的即可。 •如果堆中没有内存完成实例分配，并且堆也无法再扩展时，将抛出`OutOfMemoryError: Java heap space`。
- •**分区（基于分代垃圾回收策略）**： •**新生代（Young Generation）**：新创建的对象首先在这里分配。 •**Eden区**（伊甸园）：对象“诞生”的地方。 •**Survivor区**（幸存者区，通常有两个：S0和S1）：在Minor GC后存活的对象会从Eden区移动到Survivor区。  •**老年代（Old Generation / Tenured Generation）**：在新生代中经历了多次GC后仍然存活的对象（默认为15次），会被晋升到老年代。一些大对象（如很大的数组）也可能直接进入老年代。

**5. 方法区（Method Area）**

- •**作用**：存储已被虚拟机加载的**类型信息**、**常量**、**静态变量**、**即时编译器编译后的代码缓存**等数据。
- •**特点**： •**线程共享**。 •它有一个非常重要的部分叫做**运行时常量池（Runtime Constant Pool）**，用于存放编译期生成的各种字面量（如字符串字面量）和符号引用。
- •**演进**： •在JDK 1.7之前，方法区通常被开发者称为“永久代（PermGen）”，其内存大小受`-XX:MaxPermSize`参数限制，容易导致`OutOfMemoryError: PermGen space`。 •**从JDK 1.8开始，方法区的实现被彻底移除，取而代之的是元空间（Metaspace）**。元空间使用本地内存（Native Memory）而非JVM内存，因此其大小仅受本地内存限制，很大程度上避免了内存溢出问题。大小参数变为`-XX:MaxMetaspaceSize`。

**总结与比喻**

为了帮助你更好地理解，可以做一个简单的比喻：

- •**工厂（JVM）**：整个Java程序。
- •**工人（线程）**：工厂里的每个工人独立工作。
- •**工人的工具台（虚拟机栈）**：每个工人有自己的工具台，上面放着当前正在加工的零件（局部变量）和图纸（操作数栈、方法出口）。工具台是私人的，别人不能动。
- •**工人的指令手册（程序计数器）**：每个工人手里有一个手册，告诉他当前做到哪一步了。
- •**中央仓库（堆）**：所有工人共享的大仓库，生产出来的产品（对象实例）都放在这里。仓库管理員（GC）会定期清理没用的产品。
- •**仓库的设计图纸库（方法区）**：存放所有产品的设计蓝图（类信息）、标准规格（常量）和共享工具（静态变量）。

**总结与联系**

| 内存区域       | 线程共享？ | 作用                           | 异常                    |
| -------------- | ---------- | ------------------------------ | ----------------------- |
| **程序计数器** | **私有**   | 当前线程执行的字节码行号指示器 | **无**                  |
| **JVM栈**      | **私有**   | 存储方法调用的栈帧             | StackOverflowError, OOM |
| **本地方法栈** | **私有**   | 为Native方法服务               | StackOverflowError, OOM |
| **堆**         | **共享**   | **存放所有对象实例和数组**     | **OOM**                 |
| **方法区**     | **共享**   | 存储类信息、常量、静态变量等   | **OOM**                 |

**1 OOM ？**

​		**OOM** 是 **`OutOfMemoryError`** 的缩写。

​		**当 Java 虚拟机（JVM）因为没有足够的可用内存来分配对象，并且垃圾收集器（Garbage Collector, GC）也无法回收出足够的内存时，JVM 就会抛出 `OutOfMemoryError`。**

**2 导致OOM原因 ？**

- **情况一：流量太大，排水不及（内存泄漏/Memory Leak）**
  - 你的代码中存在一些隐蔽的引用，导致一些本该被回收的对象无法被GC回收。这些对象会持续占用内存，就像水池里的水因为某种原因排不出去。
  - 随着程序运行，这些无法释放的对象越积越多，最终撑爆内存。
  - **这是最需要警惕的情况**，因为是代码缺陷导致的。
- **情况二：水池太小，容不下正常流量（内存溢出）**
  - 你的程序本身是健康的，没有内存泄漏。但它要处理的数据量实在太大（例如，一次性从数据库加载百万条记录到内存），而分配给JVM的堆内存（`-Xmx`）又设置得过小。
  - 这种情况下，GC虽然很努力地回收垃圾，但存活的对象确实需要那么多空间，GC也无力回天。
  - 解决方法通常是调整JVM参数，增大堆内存。

### 3、Java中垃圾收集的方法有哪些

采用分区分代回收思想：

1.复制算法  

​	年轻代中使用的是Minor GC，这种GC算法采用的是复制算法(Copying)

​	a) 效率高，缺点：需要内存容量大，比较耗内存

​	b) 使用在占空间比较小、刷新次数多的新生区

2.标记-清除  

​	老年代一般是由标记清除或者是标记清除与标记整理的混合实现

​	a) 效率比较低，会差生碎片。

3.标记-整理  

​	老年代一般是由标记清除或者是标记清除与标记整理的混合实现

​	a) 效率低速度慢，需要移动对象，但不会产生碎片。

### **4、如何判断一个对象是否存活**

1.**引用计数法**

​		所谓引用计数法就是给每一个对象设置一个引用计数器，每当有一个地方引用这个对象时，就将计数器加一，引用失效时，计数器就减一。当一个对象的引用计数器为零时，说明此对象没有被引用，也就是“死对象”,将会被垃圾回收.

​		引用计数法有一个缺陷就是无法解决循环引用问题，也就是说当对象A引用对象B，对象B又引用者对象A，那么此时A,B对象的引用计数器都不为零，也就造成无法完成垃圾回收，所以主流的虚拟机都没有采用这种算法。
2.**引用链法**

​		该算法的基本思路就是通过一些被称为引用链（GC Roots）的对象作为起点，从这些节点开始向下搜索，搜索走过的路径被称为（Reference Chain)，当一个对象到GC Roots没有任何引用链相连时（即从GC Roots节点到该节点不可达），则证明该对象是不可用的。
​		在java中可以作为GC Roots的对象有以下几种：虚拟机栈中引用的对象、方法区类静态属性引用的对象、方法区常量池引用的对象、本地方法栈JNI引用的对象。

### 5、什么情况下会产生StackOverflowError（栈溢出）和OutOfMemoryError（堆溢出）怎么排查

1.引发 StackOverFlowError 的常见原因有以下几种

- 无限递归循环调用（最常见）
- 执行了大量方法，导致线程栈空间耗尽
- 方法内声明了海量的局部变量
- native 代码有栈上分配的逻辑，并且要求的内存还不小，比如 java.net.SocketInputStream.read0 会在栈上要求分配一个 64KB 的缓存（64位 Linux）。

2.引发 OutOfMemoryError的常见原因有以下几种

- 内存中加载的数据量过于庞大，如一次从数据库取出过多数据
- 集合类中有对对象的引用，使用完后未清空，使得JVM不能回收
- 代码中存在死循环或循环产生过多重复的对象实体
- 启动参数内存值设定的过小

### **6、什么是线程池，线程池有哪些（创建）**

​		线程池就是事先将多个线程对象放到一个容器中，当使用的时候就不用 new 线程而是直接去池中拿线程即可，节省了开辟子线程的时间，提高的代码执行效率。

​		在 JDK 的 java.util.concurrent.Executors 中提供了生成多种线程池的静态方法。

```java
ExecutorService newCachedThreadPool = Executors.newCachedThreadPool();

ExecutorService newFixedThreadPool = Executors.newFixedThreadPool(4);

ScheduledExecutorService newScheduledThreadPool = Executors.newScheduledThreadPool(4);

ExecutorService newSingleThreadExecutor = Executors.newSingleThreadExecutor();
```

​		然后调用他们的 execute 方法即可。

​		这4种线程池底层 全部是ThreadPoolExecutor对象的实现，阿里规范手册中规定线程池采用ThreadPoolExecutor自定义的，实际开发也是。

**1.newCachedThreadPool**

​		创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。这种类型的线程池特点是：

​		工作线程的创建数量几乎没有限制(其实也有限制的,数目为Interger. MAX_VALUE), 这样可灵活的往线程池中添加线程。

​		如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间(默认为1分钟)，则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个工作线程。

​		在使用CachedThreadPool时，一定要注意控制任务的数量，否则，由于大量线程同时运行，很有会造成系统瘫痪。

**2.newFixedThreadPool**

​		创建一个指定工作线程数量的线程池。每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中。FixedThreadPool是一个典型且优秀的线程池，它具有线程池提高程序效率和节省创建线程时所耗的开销的优点。但是，在线程池空闲时，即线程池中没有可运行任务时，它不会释放工作线程，还会占用一定的系统资源。

**3.newSingleThreadExecutor**

​		创建一个单线程化的Executor，即只创建唯一的工作者线程来执行任务，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。如果这个线程异常结束，会有另一个取代它，保证顺序执行。单工作线程最大的特点是可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。

**4.newScheduleThreadPool**

​		创建一个定长的线程池，而且支持定时的以及周期性的任务执行。例如延迟3秒执行。


### **7、为什么要使用线程池** 

​		线程池做的工作主要是控制运行的线程数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最 大数量，超出数量的线程排队等候，等其它线程执行完毕，再从队列中取出任务来执行。
​		主要特点:线程复用;控制最大并发数:管理线程。

第一:降低资源消耗。通过重复利用己创建的线程降低线程创建和销毁造成的消耗。

第二:提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。

第三:提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进 行统一的分配，调优和监控

### 8、线程池底层工作原理

1. 第一步：线程池刚创建的时候，里面没有任何线程，等到有任务过来的时候才会创建线程。当然也可以调用 prestartAllCoreThreads() 或者 prestartCoreThread() 方法预创建corePoolSize个线程
2. 第二步：调用execute()提交一个任务时，如果当前的工作线程数<corePoolSize，直接创建新的线程执行这个任务
3. 第三步：如果当时工作线程数量>=corePoolSize，会将任务放入任务队列中缓存
4. 第四步：如果队列已满，并且线程池中工作线程的数量<maximumPoolSize，还是会创建线程执行这个任务
5. 第五步：如果队列已满，并且线程池中的线程已达到maximumPoolSize，这个时候会执行拒绝策略，JAVA线程池默认的策略是AbortPolicy，即抛出RejectedExecutionException异常

### **9、ThreadPoolExecutor对象有哪些参数 怎么设定核心线程数和最大线程数 拒绝策略有哪些** 

```java
public ThreadPoolExecutor(
    int corePoolSize,
    int maximumPoolSize,
    long keepAliveTime,
    TimeUnit unit,
    BlockingQueue<Runnable> workQueue,
    ThreadFactory threadFactory,
    RejectedExecutionHandler handler
)
```

**参数与作用：**共7个参数

1. **corePoolSize：**核心线程数。核心线程会一直存活，哪怕是一直空闲着。
2. **maximumPoolSize：**最大线程数。
3. **keepAliveTime：**存活时间。当非核心空闲超过这个时间将被回收。非核心线程是指线程池中超出核心线程数的那部分线程，它们具有可回收的特性。
4. **unit：**keepAliveTime的单位。
5. **workQueue：**任务队列。常用有三种队列，即SynchronousQueue,LinkedBlockingDeque（无界队列）,ArrayBlockingQueue（有界队列）。
6. **threadFactory：**线程工厂。ThreadFactory是一个接口，用来创建worker。通过线程工厂可以对线程的一些属性进行定制。默认直接新建线程。
7. **RejectedExecutionHandler：**拒绝策略。是一个接口，只有一个方法，当线程池中的资源已经全部使用，添加新线程被拒绝时，会调用RejectedExecutionHandler的rejectedExecution法。默认是抛出一个运行时异常。

**核心线程数配置方案：**

- **CPU密集型任务**（如计算、加密）：
  核心线程数 ≈ CPU核数（避免过多线程竞争CPU）
  示例：`corePoolSize = Runtime.getRuntime().availableProcessors()`
- **I/O密集型任务**（如网络请求、文件读写）：
  核心线程数 ≈ CPU核数 × (1 + 平均等待时间/平均计算时间)
  经验值：`corePoolSize = CPU核数 * 2`

| **任务类型** | **corePoolSize** | **maximumPoolSize** | **队列容量**   |
| ------------ | ---------------- | ------------------- | -------------- |
| CPU密集型    | CPU核数          | CPU核数 + 1         | 较小（如100）  |
| I/O密集型    | CPU核数 × 2      | CPU核数 × (2~5)     | 较大（如1024） |

**拒绝策略：**

1. AbortPolicy：直接抛出异常，默认策略；
2. CallerRunsPolicy：用调用者所在的线程来执行任务；
3. DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；
4. DiscardPolicy：直接丢弃任务；当然也可以根据应用场景实现 RejectedExecutionHandler 接口，自定义饱和策略，如记录日志或持久化存储不能处理的任务。

### **10、常见线程安全的并发容器有哪些**

1. CopyOnWriteArrayList、CopyOnWriteArraySet、ConcurrentHashMap
2. CopyOnWriteArrayList、CopyOnWriteArraySet采用写时复制实现线程安全
3. ConcurrentHashMap采用分段锁的方式实现线程安全

### **11、Atomic原子类了解多少 原理是什么**

​		**Atomic原子类的主要作用是提供了一种无需加锁（如`synchronized`）即可实现线程安全操作的机制。** 它用于在多线程环境下，保证对单个变量（如整数、布尔值、对象引用）的“读-改-写”操作是原子性的、线程安全的。

```
举例：
public class Counter {
    private int count = 0;
    
    public void increment() {
        count++; // 这行代码不是线程安全的！
    }
    
    public int getCount() {
        return count;
    }
}

count++ 这个操作看起来是一步，但实际上包含了三个步骤：
    1.读取当前 count 的值。
    2.将这个值加 1。
    3.将新值写回 count。
在多线程环境下，如果两个线程同时执行 increment()，可能会发生 竞态条件（Race Condition）：
    1.线程 A 读取 count 为 0。
    2.线程 B 也读取 count 为 0。
    3.线程 A 将 0+1 的结果 1 写入 count。
    4.线程 B 也将 0+1 的结果 1 写入 count。
最终结果应该是 2，但因为操作不是原子的，结果却是 1。
传统的解决方案是使用 synchronized 关键字对方法或代码块加锁，但这会带来性能开销（线程阻塞、上下文切换）。
```

​		**Atomic原子类使用了一种更高效的方式：CAS（Compare-And-Swap）操作，避免了加锁带来的性能损耗。**

**核心原理：CAS (Compare-And-Swap)**

CAS 是一种乐观锁机制，它包含三个操作数：

1. 1.**V**：需要读写的内存位置（变量的当前值）
2. 2.**A**：进行比较的预期原值
3. 3.**B**：希望写入的新值

**CAS 的操作逻辑是：“我认为位置 V 的值应该是 A，如果是，那么将 B 放到 V 位置。否则，不要修改它，并告诉我现在的值是多少。”**

这个过程是**硬件级别（CPU 指令）** 保证的原子性，效率非常高。

1.基本类型

使用原子的方式更新基本类型

- AtomicInteger：整型原子类
- AtomicLong：长整型原子类
- AtomicBoolean：布尔型原子类

2.数组类型

使用原子的方式更新数组里的某个元素

- AtomicIntegerArray：整形数组原子类
- AtomicLongArray：长整形数组原子类
- AtomicReferenceArray：引用类型数组原子类

3.引用类型

- AtomicReference：引用类型原子类
- AtomicStampedReference：原子更新引用类型里的字段原子类
- AtomicMarkableReference ：原子更新带有标记位的引用类型
- AtomicIntegerFieldUpdater：原子更新整形字段的更新器
- AtomicLongFieldUpdater：原子更新长整形字段的更新器
- AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，以及解决使用 CAS 进行原子更新时可能出现的 ABA 问题

**优缺点总结**

| **优点**                                                     | **缺点**                                                     |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| **高性能**：基于CAS自旋，避免了线程挂起和切换的开销，在低竞争环境下优势明显。 | **ABA问题**：一个值从A变成B，又变回A，CAS会误以为它没变。可用`AtomicStampedReference`解决。 |
| **使用简单**：提供了丰富的API，如`incrementAndGet`，语义清晰。 | **循环开销**：在高竞争环境下，线程可能长时间自旋，反复尝试CAS，消耗CPU。 |
| **避免死锁**：由于是无锁操作，从根本上避免了死锁问题。       | **只能保证一个变量的原子性**：如果需要保证多个变量共同操作的原子性，仍需使用锁或`AtomicReference`封装。 |

**适用场景**

1. 1.**计数器**：如网站访问次数、订单数量统计等。
2. 2.**状态标志**：用一个原子布尔值控制某个流程的开关。`AtomicBoolean stop = new AtomicBoolean(false);`
3. 3.**非阻塞算法**：实现高效的无锁队列（如`ConcurrentLinkedQueue`）、无锁栈等复杂数据结构。
4. 4.**累积器**：收集统计数据，但不需要非常精确的实时读值。

**简单来说，当你需要对一个单一的共享变量进行高效的、线程安全的操作时，Atomic原子类是你的首选工具。**

举例：

```
===== ABA问题演示 =====
线程1: CAS(0->1) 成功
线程2: 第一次读取值 = 1
线程1: CAS(1->0) 成功
线程2: CAS(0->2) 成功
最终值: 2
结果：虽然值回到了0，但中间经历了变化（ABA问题）

===== 使用AtomicStampedReference解决ABA问题 =====
线程1: CAS(0->1) 成功
线程2: 第一次读取值 = 1, 版本号 = 1
线程1: CAS(1->0) 成功
线程2: CAS(0->2) 失败
最终值: 0, 版本号: 2
结果：版本号变化检测到了中间状态，避免了ABA问题
```

**应用场景**

1. **数据库事务系统**：在乐观锁机制中，版本号或时间戳用于检测ABA问题

2. **内存管理系统**：对象分配和回收可能重用内存地址，导致ABA问题

3. **实时交易系统**：金融交易需要确保中间状态不被忽略



### **12、synchronized底层实现是什么 lock底层是什么 有什么区别**



### **13、了解ConcurrentHashMap吗 为什么性能比HashTable高，说下原理**

​		ConcurrentHashMap是线程安全的Map容器，JDK8之前，ConcurrentHashMap使用锁分段技术，将数据分成一段段存储，每个数据段配置一把锁，即segment类，这个类继承ReentrantLock来保证线程安全，JKD8的版本取消Segment这个分段锁数据结构，底层也是使用Node数组+链表+红黑树，从而实现对每一段数据就行加锁，也减少了并发冲突的概率。

​		hashtable类基本上所有的方法都是采用synchronized进行线程安全控制，高并发情况下效率就降低 ，ConcurrentHashMap是采用了分段锁的思想提高性能，锁粒度更细化


### **14、ConcurrentHashMap底层原理**



### **15、了解volatile关键字**

1. volatile是Java提供的最轻量级的同步机制，保证了共享变量的可见性，被volatile关键字修饰的变量，如果值发生了变化，其他线程立刻可见，避免出现脏读现象。
2. volatile禁止了指令重排，可以保证程序执行的有序性，但是由于禁止了指令重排，所以JVM相关的优化没了，效率会偏弱

### **16、synchronized和volatile有什么区别**

1. volatile本质是告诉JVM当前变量在寄存器中的值是不确定的，需要从主存中读取，synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。
2. volatile仅能用在变量级别，而synchronized可以使用在变量、方法、类级别。
3. volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性。
4. volatile不会造成线程阻塞，synchronized可能会造成线程阻塞。
5. volatile标记的变量不会被编译器优化，synchronized标记的变量可以被编译器优化。

### **17、Java类加载过程** 

​		Java 类加载过程可以分为三个主要阶段：**加载（Loading）**、**链接（Linking）** 和 **初始化（Initialization）**。链接阶段又可细分为验证、准备和解析三个子阶段。

**1. 加载（Loading）**

加载阶段主要完成三件事情：

1. 1.通过类的全限定名获取定义此类的二进制字节流
2. 2.将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构
3. 3.在内存中生成该类的Class对象，作为该类的数据访问入口。

**2. 链接（Linking）**

**2.1 验证（Verification）**

​		确保Class文件的字节流包含的信息符合当前虚拟机要求，不会危害虚拟机自身安全。

- 文件格式验证：验证字节流是否符合Class文件的规范，如主次版本号是否在当前虚拟机范围内，常量池中的常量是否有不被支持的类型.
- 元数据验证:对字节码描述的信息进行语义分析，如这个类是否有父类，是否集成了不被继承的类等。
- 字节码验证：是整个验证过程中最复杂的一个阶段，通过验证数据流和控制流的分析，确定程序语义是否正确，主要针对方法体的验证。如：方法中的类型转换是否正确，跳转指令是否正确等。
- 符号引用验证：这个动作在后面的解析过程中发生，主要是为了确保解析动作能正确执行。

**2.2 准备（Preparation）**

​		为类变量（静态变量）分配内存并设置初始值。准备阶段是为类的静态变量分配内存并将其初始化为默认值，这些内存都将在方法区中进行分配。准备阶段不分配类中的实例变量的内存，实例变量将会在对象实例化时随着对象一起分配在Java堆中。

**2.3 解析（Resolution）**

​		将常量池内的符号引用替换为直接引用。该阶段主要完成符号引用到直接引用的转换动作。解析动作并不一定在初始化动作完成之前，也有可能在初始化之后。

**3. 初始化（Initialization）**

​		执行类构造器 `<clinit>()` 方法的过程，该方法由编译器自动收集类中的所有**类变量的赋值动作**和**静态语句块**中的语句合并产生。

​		初始化时类加载的最后一步，前面的类加载过程，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码。



### **18、什么是类加载器，类加载器有哪些**

​		类加载器就是把类文件加载到虚拟机中，也就是说通过一个类的全限定名来获取描述该类的二进制字节流。

**主要有以下四种类加载器**

- 启动类加载器(Bootstrap ClassLoader)用来加载java核心类库，无法被java程序直接引用
- 扩展类加载器(extension class loader):它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类
- 系统类加载器（system class loader）也叫应用类加载器：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它
- 用户自定义类加载器，通过继承 java.lang.ClassLoader类的方式实现



**Java 类加载器的实际应用场景**

1. 热部署和热加载
2. 单元测试中的模拟和隔离
3. 动态扩展和插件架构

### **19、简述java内存分配与回收策略以及Minor GC和Major GC（full GC）** 

**栈区：**栈分为java虚拟机栈和本地方法栈

**堆区：**堆被所有线程共享区域，在虚拟机启动时创建，唯一目的存放对象实例。堆区是gc的主要区域，通常情况下分为两个区块年轻代和年老代。更细一点年轻代又分为Eden区，主要放新创建对象，From survivor 和 To survivor 保存gc后幸存下的对象，默认情况下各自占比 8:1:1。

**方法区：**被所有线程共享区域，用于存放已被虚拟机加载的类信息，常量，静态变量等数据。被Java虚拟机描述为堆的一个逻辑部分。习惯是也叫它永久代（permanment generation）

**程序计数器：**当前线程所执行的行号指示器。通过改变计数器的值来确定下一条指令，比如循环，分支，跳转，异常处理，线程恢复等都是依赖计数器来完成。线程私有的。



回收策略以及Minor GC和Major GC
    1.对象优先在堆的Eden区分配
    2.大对象直接进入老年代
    3.长期存活的对象将直接进入老年代

​		当Eden区没有足够的空间进行分配时，虚拟机会执行一次Minor GC.Minor GC通常发生在新生代的Eden区，在这个区的对象生存期短，往往发生GC的频率较高，回收速度比较快;Full Gc/Major GC 发生在老年代，一般情况下，触发老年代GC的时候不会触发Minor GC,但是通过配置，可以在Full GC之前进行一次Minor GC这样可以加快老年代的回收速度。


### **20、如何查看java死锁** 



### **21、Java死锁如何避免**

造成死锁的几个原因

**1. 互斥条件 (Mutual Exclusion)**

- •资源一次只能被一个线程占用
- •示例：`synchronized` 关键字创建独占锁

**2. 请求与保持 (Hold and Wait)**

- •线程持有至少一个资源，同时请求其他线程持有的资源
- •示例：线程A持有锁1，同时请求锁2

**3. 不剥夺条件 (No Preemption)**

- •资源只能由持有线程主动释放，不能被强制剥夺
- •示例：Java 锁不能被其他线程强制释放

**4. 循环等待 (Circular Wait)**

- •存在线程资源请求的环形链
- •示例：线程A等待线程B的资源，线程B等待线程A的资源



​		这是造成死锁必须要达到的4个条件，如果要避免死锁，只需要不满足其中某一个条件即可。而其中前3个条件是作为锁要符合的条件，所以要避免死锁就需要打破第4个条件，不出现循环等待锁的关系。



在开发过程中

1.要注意加锁顺序，保证每个线程按同样的顺序进行加锁

2.要注意加锁时限，可以针对锁设置一个超时时间

3.要注意死锁检查，这是一种预防机制，确保在第一时间发现死锁并进行解决