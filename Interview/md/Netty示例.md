# Netty示例

## 一、概述

### 1 简介

​		**Netty 是一个高性能、异步事件驱动的网络应用程序框架。**它的主要目的是简化和支持快速开发可维护的高性能、高可扩展性协议服务器和客户端。

​		可以把它理解为 **Java NIO（Non-Blocking I/O） 的“超级增强版”**。它封装了复杂的 Java NIO API，提供了一个更易于使用、更健壮、功能更强大的编程模型。



### 2 目的

​		在传统 Java 网络编程中（BIO），每个连接都需要一个独立的线程，当并发连接数很高时（如十万级），线程上下文切换的开销巨大，甚至可能导致系统崩溃。

​		Java 自 1.4 引入了 NIO，提供了非阻塞 I/O 的能力，可以用一个线程处理多个连接。但 **NIO 的原生 API 非常复杂和繁琐**，开发者需要直接与 `Channel`、`Selector`、`ByteBuffer`等打交道，并处理很多底层细节（如TCP粘包/拆包、网络闪断等），开发效率和代码可维护性都很低。

**Netty 的出现就是为了解决这些问题：**

- **简化 NIO 开发**： 提供优雅的 API，隐藏底层复杂性。
- **高性能和高吞吐**： 精心优化的架构，性能远超传统 BIO 和直接使用 NIO。
- **稳定性**： 处理了 NIO 中很多常见的 Bug（如 `epoll bug`导致的 CPU 100%）。
- **强大的社区和生态**： 众多知名项目（如 Dubbo、RocketMQ、Elasticsearch、gRPC、Spark等）都在使用 Netty，证明了其稳定性和性能。



### 3 架构与组件

**1. Channel（通道）**

- 这是 Netty 网络操作的抽象类，代表一个到实体（如一个硬件设备、一个文件、一个网络套接字等）的开放连接。所有 I/O 操作都是通过 `Channel`进行的。



**2. EventLoop（事件循环） & EventLoopGroup（事件循环组）**

​		这是 Netty 的**心脏**，实现了 Reactor 线程模型。

**EventLoop**： 一个不断循环的线程，负责处理一个或多个 Channel 的 I/O 事件和任务。 

- 它的生命周期内只绑定一个 `Thread`。 
- 一个 `EventLoop`可以注册多个 `Channel`。
- 一个 `Channel`在它的生命周期内只注册到一个 `EventLoop`。

**EventLoopGroup**： 是多个 `EventLoop`的集合，可以理解为线程池。 

通常服务器会有两个组： 

- **BossGroup**： 负责接收客户端的连接，然后将连接注册到 **WorkerGroup**中的一个 `EventLoop`上。

- **WorkerGroup**： 负责处理已被接受的连接的 I/O 读写等事件。



**3. ChannelFuture（异步通知）**

​		Netty 中所有的 I/O 操作都是**异步**的。这意味着任何 I/O 调用都会立即返回，而不保证操作完成。`ChannelFuture`就是用来在操作完成时通知应用程序的。你可以给它添加监听器，以便在操作完成、成功或失败时得到回调。



**4. ChannelHandler & ChannelPipeline（处理器和处理链）**

这是 Netty 的**大脑**，负责处理数据的流入和流出。

**ChannelHandler**： 是处理入站和出站数据的业务逻辑的容器。你可以把它想象成一个一个的“处理单元”。常见的子接口有： 

- `ChannelInboundHandler`： 处理入站数据（如读取到的数据、连接建立等事件）。
- `ChannelOutboundHandler`： 处理出站数据（如写入数据、关闭连接等操作）。

**ChannelPipeline**： 为 `ChannelHandler`链提供了一个容器。当数据流经一个 Channel 时，它会被 `ChannelPipeline`中的一系列 `ChannelHandler`依次处理。这就像一个流水线或者过滤器链。



**5. ByteBuf（字节缓冲区）**

​		Netty 自己实现的字节容器，替代了 NIO 的 `ByteBuffer`，提供了更强大、更灵活的功能：

- **读写索引分离**： 不需要像 `ByteBuffer`一样手动调用 `flip()`来切换读写模式。
- **池化**： 可以池化 `ByteBuf`实例，减少 GC 压力，提升性能。
- **支持复合缓冲区**： 可以轻松组合多个 `ByteBuf`。



### 4 工作原理

Netty 的线程模型基于主从 Reactor 多线程模型的变体。

1. **BossGroup**中的 `EventLoop`（主 Reactor） 通过一个 `Selector`轮询客户端的**连接请求**。
2. 当有新的连接到来时，`BossGroup`会接收连接，并创建一个 `Channel`。
3. 然后，`BossGroup`将这个 `Channel`注册到 **WorkerGroup**中的某个 `EventLoop`（从 Reactor） 上。
4. 此后，该连接的所有 **I/O 读写事件**（如读数据、写数据）都由这个特定的 `EventLoop`负责处理。它会将事件传递给该 `Channel`对应的 `ChannelPipeline`。
5. `ChannelPipeline`中的 `ChannelHandler`链会依次对数据进行处理（如解码、业务逻辑、编码等）。

**这种设计的好处是：**

- **职责清晰**： 连接请求和 I/O 处理分离。
- **高性能**： 将连接均匀地分散到多个 `EventLoop`上，避免了多线程竞争。
- **资源高效**： 一个连接的生命周期内只由一个线程处理，实现了无锁化。





## 二、其他

### 1 NIO与BIO

**BIO（阻塞 I/O）**

1、工作原理

BIO 是 JDK 1.4 之前唯一的 I/O 模型。它的核心特点是 **"阻塞"**。

- **读操作**：当线程调用 `read()`方法时，如果通道中没有数据可读，线程会一直**阻塞**，直到有数据到达。
- **写操作**：当线程调用 `write()`方法时，如果输出缓冲区已满，线程会**阻塞**，直到缓冲区有空间。
- **连接接受**：服务器线程调用 `accept()`方法时，会**阻塞**，直到有客户端连接进来。

2、典型实现：线程池模型

为了解决"一个连接一个线程"导致的线程资源耗尽问题，通常使用**线程池**。

```java
// 伪代码示例
ServerSocket serverSocket = new ServerSocket(8080);
ExecutorService threadPool = Executors.newFixedThreadPool(100); // 线程池

while (true) {
    // 1. 主线程阻塞，等待客户端连接
    Socket socket = serverSocket.accept(); 

    // 2. 有连接到来，将Socket交给线程池中的某个线程处理
    threadPool.execute(() -> {
        // 3. 工作线程读写数据（这里也会阻塞！）
        InputStream in = socket.getInputStream();
        in.read(...); // 阻塞，直到客户端发送数据
        // ... 处理数据
    });
}
```

3、BIO 的优缺点

**优点**： 

- **编程简单**：代码直观，易于理解和调试。
- **适合低并发**：在连接数不多的情况下，性能可以接受。

**缺点**：

- **资源消耗大**：每个连接都需要一个独立的线程，线程本身占用大量内存，线程上下文切换开销大。 
- **可扩展性差**：当连接数达到数千甚至上万时，创建这么多线程不现实，系统会崩溃。



**NIO（非阻塞 I/O）**

​		NIO 在 JDK 1.4 引入，旨在解决 BIO 的性能瓶颈。其核心是 **"非阻塞"**和 **"多路复用"**。

**1、 三大核心组件**

**a) 通道（Channel）**

- 替代了 BIO 中的 `InputStream`和 `OutputStream`。
- **通道是双向的**：既可以读，也可以写。

- 常见实现：`FileChannel`、`DatagramChannel`、`SocketChannel`、`ServerSocketChannel`。

**b) 缓冲区（Buffer）**

- 所有数据的读写都必须通过 **Buffer**。
- 是一个线性的、有限的数据容器，有读/写模式。

- 常见实现：`ByteBuffer`、`CharBuffer`、`IntBuffer`等。

**c) 选择器（Selector）**

- NIO 的**灵魂**。一个 Selector 可以轮询多个 Channel 上的事件（连接到来、数据可读、数据可写）。
- 单个线程可以管理多个 Channel，从而管理多个网络连接。

**2、工作原理：多路复用**

​		NIO 的工作模式通常被称为 **Reactor 模式**。

**3、 NIO 的优缺点**

**优点**： 

- **高并发**：单线程即可处理大量连接，资源消耗小。
- **非阻塞**：I/O 操作不会阻塞线程，线程效率高。

**缺点**： 

- **编程复杂**：API 复杂，需要处理缓冲区、选择器、网络事件等。 
- **调试困难**：异步回调模式使得调试和问题追踪比 BIO 困难。



**区别：**

#### 1、阻塞 vs. 非阻塞

- **BIO**：线程在等待数据时会被挂起，什么也做不了，**浪费 CPU 时间**。

- **NIO**：线程发起读请求，如果没数据，立即返回一个状态（如 0），线程可以**马上去做别的事情**（比如处理其他已就绪的 Channel）。

#### 2. 面向流 vs. 面向缓冲区

- **BIO（流）**：数据像水管里的水，单向流动。你只能从流中顺序读取，不能前后移动。

- **NIO（缓冲区）**：数据先被读到一个"桶"（Buffer）里。你可以在这个桶里前后移动，灵活处理数据。

#### 3. 线程模型

**BIO**：一个连接对应一个线程。1万个连接需要1万个线程。

> **比喻**：一个餐厅，每来一个客人就配一个专属服务员。

**NIO**：一个线程可以处理成千上万个连接。 

> **比喻**：一个餐厅，只有一个服务员（Selector），但他有一个呼叫器列表。他站在中央，哪桌客人需要点菜或上菜（事件就绪），呼叫器就响，他再过去服务。





