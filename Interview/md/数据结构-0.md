# 数据结构

## 1 树

​		**树（Tree）** 是一种**非线性数据结构**，由n（n≥0）个有限节点组成的一个具有层次关系的集合。当n=0时，称为空树。

**核心特点：**

1. **唯一根节点**：最顶层的节点
2. **子树不相交**：除根节点外，每个节点有且仅有一个父节点
3. **递归定义**：每个节点都可以看作一棵子树的根

**基本术语：**

- **节点（Node）**：树的基本单元
- **根节点（Root）**：没有父节点的节点
- **父节点/子节点**：直接的上下级关系
- **叶子节点（Leaf）**：没有子节点的节点
- **边（Edge）**：节点间的连接
- **度（Degree）**：节点的子节点数
- **深度（Depth）**：根到该节点的唯一路径长度
- **高度（Height）**：节点到最深叶子节点的路径长度
- **层（Level）**：深度相同的节点集合

### 1.1 二叉树

​		每个节点最多有**两个子节点**（左孩子、右孩子）

类型：

**1. 满二叉树 (Full Binary Tree)**

- **定义**：每个节点都有 **0 个或 2 个**子节点（即没有只有 1 个子节点的节点）。

```
      A
     / \
    B   C
   / \ 
  D   E
```

（B 有两个子节点，C 是叶子节点，符合 0 或 2 个子节点的规则）

**2. 完全二叉树 (Complete Binary Tree)**

- **定义**：除最后一层外，每层都填满节点，且最后一层的节点尽可能靠左排列。
- **特点**：常用于堆（Heap）结构，可用数组高效存储。

```
      A
     / \
    B   C
   / \  /
  D   E F
```

（最后一层节点靠左，中间没有空缺）

**3. 完美二叉树 (Perfect Binary Tree)**

- **定义**：所有叶子节点都在同一层，且每个非叶子节点都有两个子节点（是一种特殊的满二叉树）。
- **节点数**：若深度为 h，则节点总数为 2h−1。
- **示例**（深度 3）：

```
      A
     / \
    B   C
   / \ / \
  D  E F  G
```

**4. 平衡二叉树 (Balanced Binary Tree)**

- **定义**：任意节点的左右子树高度差不超过 1（或满足特定平衡条件）。
- **目的**：避免树退化为链表，保证操作效率（如 AVL 树、红黑树）。
- **示例**（AVL 树）：

```
      A
     / \
    B   C
   /   / \
  D   E   F
```

**5. 二叉搜索树 (Binary Search Tree, BST)**

- **定义**：对任意节点，左子树的所有节点值小于它，右子树的所有节点值大于它。
- **用途**：快速查找、插入、删除（平均 O(logn)）。

```
      4
     / \
    2   6
   / \ / \
  1  3 5  7
```

**6. 退化二叉树 / 斜树 (Degenerate Binary Tree)**

- **定义**：每个节点只有左子节点或只有右子节点，退化为链表结构。

```
A
   \
    B
     \
      C
```

**7. 线索二叉树 (Threaded Binary Tree)**

- **定义**：将空的左右指针域改为指向某种遍历顺序下的前驱或后继节点，加速遍历。
- **用途**：无需递归/栈即可实现中序、前序等遍历。



### 1.2 特殊二叉树

#### **1 AVL 树**

​		AVL 树是 **自平衡的二叉搜索树（Self-balancing Binary Search Tree）**，它同时具备以下两个性质：

- **二叉搜索树性质**：左子树的所有节点值 < 根节点值 < 右子树的所有节点值。
- **平衡性质**：对于任意节点，其 **左子树高度与右子树高度之差（平衡因子）的绝对值不超过 1**。

**关键机制**

**平衡因子**：**平衡因子 (BF)** = 左子树高度 - 右子树高度（`BalanceFactor = height(left_subtree) − height(right_subtree)`）。 平衡因子只可能是 `-1`、`0`或 `1`（合法范围：{-1, 0, 1}）。同一节点的左右子树高度不超过1。当 BF 超出范围时，根据不平衡类型进行旋转。

**旋转操作**：当插入或删除节点导致平衡因子超出范围时，通过 **单旋转或双旋转** 恢复平衡。

 左旋（Right-heavy 时使用） 

右旋（Left-heavy 时使用） 

左右旋 / 右左旋（LR 或 RL 情况）

**为什么需要 AVL 树？**

- 普通二叉搜索树在极端情况下（如按顺序插入数据）会退化为链表，操作复杂度降至 O(n)。
- AVL 树通过强制平衡，保证 **查找、插入、删除的最坏时间复杂度均为 O(logn)**。

**结论**

- **AVL 树是平衡搜索树**，且是 **最早发明的自平衡二叉搜索树** 之一。
- 它保证了严格的平衡条件，因此在需要频繁查找而较少插入/删除的场景中表现优异。
- 如果需要更灵活的平衡（减少旋转开销），红黑树是更常见的选择。

**旋转操作示例：**

**1 左旋 (Left Rotation)**

**触发条件**：在节点的**右子树**的**右子树**插入导致失衡（RR 型）

```
步骤：
1. 找到第一个 BF = -2 的失衡节点 A
2. 对 A 执行左旋

初始（平衡）：
    A (BF=-1)
     \
      B (BF=0)
       \
        C        ← 插入 C 后检查

插入 C 后，A 的 BF = -2（右子树太重，RR 型）
    A (BF=-2)  ← 失衡点
     \
      B (BF=-1)
       \
        C (BF=0)

左旋操作（以 A 为轴左旋）：
1. 将 B 提升为新的根
2. A 成为 B 的左子节点
3. B 原来的左子树（如果有）成为 A 的右子树

结果：
      B (BF=0)
     / \
    A   C
(BF=0) (BF=0)
```

**2 右旋 (Right Rotation)**

**触发条件**：在节点的**左子树**的**左子树**插入导致失衡（LL 型）

```
步骤：
1. 找到第一个 BF = +2 的失衡节点 A
2. 对 A 执行右旋

初始：
        A (BF=+1)
       /
      B (BF=0)
     /
    C         ← 插入 C 后检查

插入 C 后，A 的 BF = +2（左子树太重，LL 型）
        A (BF=+2)  ← 失衡点
       /
      B (BF=+1)
     /
    C (BF=0)

右旋操作（以 A 为轴右旋）：
1. 将 B 提升为新的根
2. A 成为 B 的右子节点
3. B 原来的右子树（如果有）成为 A 的左子树

结果：
      B (BF=0)
     / \
    C   A
(BF=0) (BF=0)
```

**3 左右旋 (Left-Right Rotation)**

**触发条件**：在节点的**左子树**的**右子树**插入导致失衡（LR 型）

```
步骤：
1. 对失衡节点 A 的左子节点 B 先执行左旋
2. 再对 A 执行右旋

插入前：
    A (BF=+1)
   /
  B (BF=0)

在 B 的右子树插入 C 后：
    A (BF=+2)  ← 失衡点
   /
  B (BF=-1)
   \
    C (BF=0)

这是 LR 型（先左后右）：
**第一步**：对 B 左旋（B 是 C 的父节点）
    A
   /
  C
 /
B

**第二步**：对 A 右旋
      C (BF=0)
     / \
    B   A
(BF=0)(BF=0)
```

**4 右左旋 (Right-Left Rotation)**

**触发条件**：在节点的**右子树**的**左子树**插入导致失衡（RL 型）

```
步骤：
1. 对失衡节点 A 的右子节点 B 先执行右旋
2. 再对 A 执行左旋

插入前：
    A (BF=-1)
     \
      B (BF=0)

在 B 的左子树插入 C 后：
    A (BF=-2)  ← 失衡点
     \
      B (BF=+1)
     /
    C (BF=0)

这是 RL 型（先右后左）：
**第一步**：对 B 右旋
    A
     \
      C
       \
        B

**第二步**：对 A 左旋
      C (BF=0)
     / \
    A   B
(BF=0)(BF=0)
```





#### **2 红黑树**

​		红黑树是一种**自平衡的二叉搜索树**，它通过一组简单的规则保证树的大致平衡，从而保证基本操作在最坏情况下的时间复杂度为 **O(log n)**。

**五大规则**

每个节点都有一个颜色属性（红色或黑色），必须满足：

1. **节点颜色**：每个节点是红色或黑色。
2. **根节点**：根节点必须是黑色。
3. **叶子节点**：所有叶子节点（NIL 节点，空节点）都是黑色。
4. **红色节点规则**：红色节点的两个子节点必须是黑色（即**不能有连续的红色节点**）。
5. **路径规则**：从任一节点到其每个叶子（NIL）的所有路径包含**相同数量**的黑色节点。

**关键概念**

- **黑高（Black Height）**：从节点到其叶子节点路径上的黑色节点数量（不包括自身）。
- **NIL 节点**：虚拟的叶子节点，视为黑色，实际实现中通常用空指针表示。
- **近似平衡**：规则5保证了最长路径不超过最短路径的2倍。

| 比较项         | AVL 树                   | 红黑树                             |
| -------------- | ------------------------ | ---------------------------------- |
| **平衡严格度** | 严格平衡（高度差 ≤ 1）   | 近似平衡（最长路径 ≤ 2倍最短路径） |
| **插入/删除**  | 可能需要多次旋转         | 旋转次数较少，最多3次旋转          |
| **查找效率**   | 略优（严格平衡）         | 略低，但仍是 O(log n)              |
| **应用场景**   | 读多写少（如数据库索引） | 写多读少（如语言标准库）           |

**红黑树优点**：插入/删除时旋转次数少，更适合频繁修改的场景。







#### **3 堆（Heap）**

​		堆是一种特殊的**完全二叉树**，满足堆属性（Heap Property）。它是实现优先队列的高效数据结构。

**完全二叉树**：除了最后一层，其他层都是满的，最后一层从左到右填充

**堆属性**： 

- **大顶堆（Max Heap）**：父节点值 ≥ 子节点值 
- **小顶堆（Min Heap）**：父节点值 ≤ 子节点值

示例

```
大顶堆：
       100
      /    \
     19     36
    /  \    / \
   17   3  25  1
  / \
 2   7

小顶堆：
         1
       /   \
      2     3
     / \   / \
    17 19 36  25
   /
  100
```

堆通常用**数组**存储（利用完全二叉树性质）：

对于下标 `i`的节点： 

- 父节点下标：`(i-1)/2` 
- 左子节点下标：`2*i + 1` 
- 右子节点下标：`2*i + 2`

```
数组下标: 0   1   2   3   4   5   6   7   8
值:      100 19  36  17  3   25  1   2   7

树形表示：
       100(0)
      /      \
    19(1)    36(2)
    /   \     /   \
  17(3) 3(4) 25(5) 1(6)
  /   \
2(7)  7(8)
```



**堆的操作**

**1 插入（上浮操作）**

**步骤**：

1. 将新元素添加到堆的末尾
2. 与父节点比较，如果违反堆属性则交换（上浮）
3. 重复直到满足堆属性

**示例**：在小顶堆 `[1, 3, 6, 5, 9, 8]`中插入 `2`

```

初始堆：
       1
      / \
     3   6
    / \   \
   5   9   8

插入2（先放到末尾）：
       1
      / \
     3   6
    / \   \
   5   9   8
  /
 2

上浮操作：
1. 2 < 5? 是 → 交换
       1
      / \
     3   6
    / \   \
   2   9   8
  /
 5

2. 2 < 3? 是 → 交换
       1
      / \
     2   6
    / \   \
   3   9   8
  /
 5

3. 2 < 1? 否 → 停止
最终堆：`[1, 2, 6, 3, 9, 8, 5]`
```

**时间复杂度**：O(log n)

------

**2 删除堆顶（下沉操作）**

**步骤**：

1. 用最后一个元素替换堆顶
2. 与子节点比较，如果违反堆属性则交换（下沉）
3. 重复直到满足堆属性

**示例**：从大顶堆 `[100, 19, 36, 17, 3, 25, 1, 2, 7]`删除堆顶

```

初始堆：
       100
      /    \
     19     36
    /  \    / \
   17   3  25  1
  / \
 2   7

1. 用最后一个元素7替换堆顶：
       7
      /    \
     19     36
    /  \    / \
   17   3  25  1
  / 
 2

2. 下沉操作：
   7 < max(19, 36)? 是 → 与36交换
       36
      /    \
     19     7
    /  \    / \
   17   3  25  1
  / 
 2

   7 < max(25, 1)? 是 → 与25交换
       36
      /    \
     19     25
    /  \    / \
   17   3  7   1
  / 
 2

3. 7已满足堆属性 → 停止
最终堆：`[36, 19, 25, 17, 3, 7, 1, 2]`
```

**时间复杂度**：O(log n)

------

**3 获取堆顶元素**

- 大顶堆：返回最大值（数组第一个元素）
- 小顶堆：返回最小值（数组第一个元素）



- **时间复杂度**：O(1)

------

**4 建堆（Heapify）**

**方法1：自底向上（Floyd算法）**

​		从最后一个非叶子节点开始，向前逐个进行下沉操作

**示例**：将数组 `[4, 10, 3, 5, 1]`构建为大顶堆

```

初始数组：[4, 10, 3, 5, 1]
树形表示：
       4
      / \
     10  3
    / \
   5   1

1. 最后一个非叶子节点下标 = (n/2)-1 = 1 → 节点10
   10 ≥ max(5, 1)? 是 → 不变

2. 处理节点4（下标0）：
   4 < max(10, 3)? 是 → 与10交换
       10
      /  \
     4    3
    / \
   5   1

   4 < max(5, 1)? 是 → 与5交换
       10
      /  \
     5    3
    / \
   4   1

最终大顶堆：[10, 5, 3, 4, 1]
```

**时间复杂度**：O(n)（不是 O(n log n)，因为大部分节点下沉深度小）



**堆的应用**

**1 优先队列**

- 出队：删除堆顶
- 入队：插入元素



- Java：`PriorityQueue`，C++：`priority_queue`

**2 堆排序**

**步骤**：

1. 构建大顶堆
2. 交换堆顶与最后一个元素
3. 堆大小减1，对堆顶下沉
4. 重复2-3直到堆大小为1

**示例**：对 `[4, 10, 3, 5, 1]`堆排序

```

初始：[4, 10, 3, 5, 1]
建堆：[10, 5, 3, 4, 1]

1. 交换10和1 → [1, 5, 3, 4, 10]，堆大小4
   下沉 → [5, 4, 3, 1, 10]

2. 交换5和1 → [1, 4, 3, 5, 10]，堆大小3
   下沉 → [4, 1, 3, 5, 10]

3. 交换4和3 → [3, 1, 4, 5, 10]，堆大小2
   下沉 → [3, 1, 4, 5, 10]

4. 交换3和1 → [1, 3, 4, 5, 10]，堆大小1

排序结果：[1, 3, 4, 5, 10]
```

**时间复杂度**：O(n log n)，**原地排序**

**3 求Top K问题**

**求最大的K个元素**：

1. 维护一个大小为K的**小顶堆**
2. 遍历元素： 如果堆大小 < K：直接插入；如果堆大小 = K：如果元素 > 堆顶，替换堆顶并下沉
3. 最终堆中就是最大的K个元素

**示例**：数组 `[3, 2, 1, 5, 6, 4]`，求最大的2个元素

```

1. 建小顶堆，K=2
2. 插入3,2 → 堆：[2, 3]
3. 插入1：1 < 堆顶2? 否 → 忽略
4. 插入5：5 > 堆顶2? 是 → 替换 → 堆：[3, 5]
5. 插入6：6 > 堆顶3? 是 → 替换 → 堆：[5, 6]
6. 插入4：4 > 堆顶5? 否 → 忽略
结果：[5, 6]
```

**时间复杂度**：O(n log K)

