# MySQL原理示例

## 一、概述

### 1 架构

​		MySQL 的核心特点是其**可插拔的存储引擎架构**，将数据库系统分为服务层和存储引擎层。这种架构使得不同存储引擎可以在同一个 MySQL 实例中共存。

```
+-----------------------------------+      | 客户端 (PHP, Java, Python...)
|            连接池                 |      | 发送 SQL 语句，获取结果
|            管理服务               |      |
|             SQL 接口              | <---+
|            解析器 Parser          |
|            优化器 Optimizer       |
|            查询缓存 (8.0已移除)    |
+-----------------------------------+
|          可插拔存储引擎层           |
|   +---------+ +----+ +---------+  |
|   | InnoDB  | |MyISAM| |Memory| ...|
|   +---------+ +----+ +---------+  |
+-----------------------------------+
|            文件系统                |
|   数据文件、日志文件、索引文件...     |
+-----------------------------------+
```

**a) 服务层（Server Layer）**

这一层负责所有跨存储引擎的通用功能。

- **连接管理：**处理客户端连接、认证、安全。
- **SQL 接口：**接收 SQL 命令（DML, DDL, 存储过程等），并返回结果。
- **解析器：**对 SQL 语句进行词法分析和语法分析，生成一颗“解析树”。
- **优化器：**这是最核心、最复杂的组件之一。**它会对解析树进行优化，决定使用哪个索引，决定多表关联（JOIN）的顺序和方式等。最终生成一个**执行计划**。 **

> 例子：对于 `SELECT * FROM users WHERE id > 10 AND name LIKE ‘A%’;`，优化器会判断是先按 `id`索引过滤再检查 `name`，还是全表扫描后再过滤，哪种成本更低。

**b) 存储引擎层（Storage Engine Layer）**

- 负责数据的**存储和提取**。存储引擎是真正的“仓库管理员”。
- MySQL 通过定义良好的 API 与服务层交互，这些 API 屏蔽了不同存储引擎的差异。
- **最常用的引擎是 InnoDB**（MySQL 5.5.5 后的默认引擎）。



### 2 核心存储引擎InnoDB的原理

​		InnoDB 支持事务、行级锁、外键等关键特性。

#### 2.1 数据存储结构

- **表空间：**InnoDB 的所有数据都存储在**表空间**中。可以看作一个逻辑上的大容器。
- **段：**表由不同的段组成，如数据段、索引段。
- **区：**由连续的页组成，大小为 1MB（64个连续的16KB页）。
- **页：**是 InnoDB 磁盘管理的最小单位**，默认大小为 16KB。**所有读写操作最终都是以页为单位进行的。页中存放着多行记录。

- **行：**数据按行存储。InnoDB 支持两种文件格式（Antelope, Barracuda）来管理行格式（如 Compact, Redundant, Dynamic, Compressed），这影响了像 `VARCHAR`、`TEXT`、`BLOB`这类可变长字段的存储方式。

**关键思想：**为了避免频繁的随机磁盘 I/O，InnoDB 会将查询涉及到的整个**页**加载到内存中（Buffer Pool）。



#### 2.2 内存结构

##### Buffer Pool(缓冲池)

​		**Buffer Pool：**是 InnoDB 在内存中开辟的一个**重要区域**，用来缓存数据和索引的页。它是影响性能的关键参数（由 `innodb_buffer_pool_size`控制）。

**工作方式：** 

1. 当需要读取一页数据时，首先检查它是否在 Buffer Pool 中。
2. 如果在（命中），则直接读取。 如果不在（未命中），则从磁盘读取该页到 Buffer Pool 中，然后才进行读取。
3. 当需要修改数据时，直接修改 Buffer Pool 中的页（称为“脏页”）。这些脏页会由后台线程在适当的时候**刷回**磁盘（这个操作称为 **Checkpoint**）。

**作用：**通过减少磁盘 I/O 来极大提升性能。将“随机写”转换为“顺序写”。

**Checkpoint机制：**

- 标记已刷盘的LSN（Log Sequence Number）
- 崩溃恢复时从Checkpoint点开始重放Redo Log

**缓冲池内部结构：**

- **数据页缓存**：表和索引数据
- **Change Buffer**：二级索引变更缓存
- **自适应哈希索引**：自动建立的哈希索引
- **锁系统**：行锁管理
- **插入缓冲**：已废弃，被Change Buffer取代



##### Log Buffer (日志缓冲区)

- 缓存重做日志(Redo Log)条目
- 定期或事务提交时刷到Redo Log文件
- 大小由`innodb_log_buffer_size`控制





#### 2.3 事务原理：ACID 的实现

##### A - Atomicity（原子性）

**定义**：一个事务（Transaction）被视为一个不可分割的最小工作单元。事务中的所有操作要么**全部成功**，要么**全部失败**，不会停留在中间状态。不存在部分成功的情况。

**比喻**：就像银行转账，从A账户扣款和向B账户加款这两个操作必须作为一个整体。不可能发生A账户的钱扣了，但B账户没收到钱的情况。

**在MySQL(InnoDB)中的实现机制**：**Undo Log（回滚日志）**

**工作流程**： 

1. 在事务中修改任何数据**之前**，InnoDB 会先将数据的**原始值**拷贝到 Undo Log 中。
2. 然后才修改内存（Buffer Pool）中的数据。
3. 如果事务执行过程中出现问题（如断电、手动 `ROLLBACK`），InnoDB 可以利用 Undo Log 中的记录，将数据**回滚**到事务开始前的状态。 
4. 如果事务成功提交（`COMMIT`），Undo Log 中的记录会在后续被清理（当没有其他事务需要这些记录来实现多版本控制时）。

##### C - Consistency（一致性）

**定义**：事务必须使数据库从一个**一致性状态**转换到另一个**一致性状态**。一致性状态指的是数据库中的数据满足预定义的规则，包括各种约束，如主键唯一、外键约束、数据类型检查等。

**重要理解**：一致性是事务的**最终目标**。原子性、隔离性和持久性都是实现一致性的**手段**。

- **原子性**保证了一个事务内的操作要么全做要么全不做，避免了中间状态导致的不一致。
- **隔离性**保证了并发事务之间不会相互干扰，避免了脏读、幻读等导致的不一致。

- **持久性**保证了提交的事务不会丢失，确保了数据改变的永久性。

**在MySQL中的实现机制**：

- 这部分主要由数据库的**业务逻辑**和**约束检查**来保证。
- 例如，如果你定义了 `age INT UNSIGNED`，那么插入一个负数会被 MySQL 拒绝，事务会回滚，从而保证数据库不会进入“年龄为负”这个不一致的状态。
- 数据库自身通过 A、I、D 这三个特性，为应用层达成“一致性”提供了坚实的基础。

##### I - Isolation（隔离性）

**定义**：在并发环境下，多个事务同时执行时，一个事务的执行**不应影响**其他事务的执行。数据库系统提供不同的隔离级别，允许你在**性能**和**数据准确性**之间进行权衡。

**比喻**：多个线程在操作同一份数据，隔离性就是给它们设定规则，比如有的可以同时读，有的需要等别人写完再读，以避免产生混乱。

**在MySQL(InnoDB)中的实现机制**：**锁（Lock）机制**和 **MVCC（多版本并发控制）**

**锁（Lock）**： 

- **共享锁（S Lock）**：允许事务读一行数据。多个事务可以同时持有同一数据的共享锁。 
- **排他锁（X Lock）**：允许事务更新或删除数据。一个事务持有排他锁时，其他事务无法对该数据加任何锁。

锁可以加在行、页、表等不同粒度上。InnoDB 主要使用**行级锁**，极大提高了并发性能。

**MVCC（多版本并发控制）**： 

- 这是 InnoDB 实现高并发的关键。它不通过加锁来读取数据，而是为每个数据行维护多个版本（快照）。 
- 当某个事务需要读取数据时，它看到的是在其开始之前就已经提交的**数据快照**。这样，读操作不会阻塞写操作，写操作也不会阻塞读操作。 
- 实现方式是通过每行记录中的隐藏字段：`DB_TRX_ID`（最近修改它的事务ID）和 `DB_ROLL_PTR`（指向 Undo Log 中旧版本数据的指针），形成一个版本链。

**隔离级别**：

​		MySQL 提供了4个标准隔离级别，隔离级别从低到高，并发性能下降，数据准确性上升。

- **读未提交（Read Uncommitted）**：一个事务能读到其他事务**未提交**的修改。存在**脏读**问题。
- **读已提交（Read Committed）**：一个事务只能读到其他事务**已提交**的修改。解决了脏读，但存在**不可重复读**问题（同一事务内两次读取同一数据，结果不同）。
- **可重复读（Repeatable Read）**：**InnoDB的默认级别**。保证在同一个事务中，多次读取同一数据的结果是一致的。解决了不可重复读，但可能存在**幻读**问题（同一事务内两次查询，第二次查询看到了第一次查询未看到的新增行）。InnoDB 通过 **Next-Key Locking**算法在很大程度上解决了幻读问题。
- **可串行化（Serializable）**：最高的隔离级别，强制事务串行执行，性能最低。它通过在每个读操作上都加锁来避免所有并发问题。

##### D - Durability（持久性）

**定义**：一旦事务**成功提交（COMMIT）**，它对数据库所做的改变就是**永久性**的。即使发生系统崩溃（如断电），数据也不会丢失。

**比喻**：你将文件保存到硬盘后，即使电脑断电，文件依然在硬盘上，而不是只在内存中。

**在MySQL(InnoDB)中的实现机制**：**Redo Log（重做日志）**和 **WAL（Write-Ahead Logging，预写式日志）策略**

**WAL 策略的核心**：**先写日志，再写数据**。

**工作流程**： 

1. 当事务提交时，InnoDB 会先把该事务的所有修改操作**顺序地**写入 **Redo Log Buffer**（内存中）。 
2. 然后将 Redo Log Buffer 中的内容**刷盘**到 **Redo Log File**（磁盘上）。这是一个**顺序写**操作，速度非常快。 
3. 一旦 Redo Log 落盘成功，事务就算提交成功了。此时会返回成功信息给客户端。
4. **之后**，InnoDB 再通过后台线程，将内存（Buffer Pool）中的“脏页”**异步**地刷新到磁盘的数据文件中。这是一个**随机写**操作，速度较慢。

**崩溃恢复**： 如果数据库在脏页刷盘之前发生崩溃，重启后，InnoDB 会根据 Redo Log 文件中的记录，**重做**（Redo）所有已提交但尚未写入数据文件的操作，从而保证持久性。





#### 2.4 索引原理：B+Tree

​		InnoDB 使用 **B+Tree**数据结构来存储索引和数据。

**聚簇索引：**表数据本身就按主键顺序组织在一颗 B+Tree 上。叶子节点直接存放完整的行数据。**一张表必须有且只有一个聚簇索引。**

**二级索引（辅助索引）：**叶子节点存储的不是行数据，而是该索引字段的值和对应的**主键值**。当通过二级索引查询时，需要先查到主键，再回到聚簇索引中查找完整数据，这个过程称为**回表**。

**B+Tree 的优势：** 矮胖的树形结构，层级少，查询效率高（通常3-4层就能存储海量数据）。 所有数据都存储在叶子节点，且叶子节点之间有指针相连，非常适合范围查询（如 `id > 5`）和全表扫描。

**B+Tree关键特性：**

- 所有数据存储在叶子节点
- 非叶子节点只存储键值和子节点指针
- 叶子节点通过指针相连，支持高效范围查询
- 树高度平衡，查询性能稳定

**回表查询流程：**

1. 在二级索引`idx_age`中找到`age=25`的所有主键
2. 用主键值到聚簇索引中查找完整行数据
3. 返回查询结果



#### 2.5 日志系统原理

##### Redo Log机制

**1 LSN(Log Sequence Number)管理**

1.1 LSN分配规则：

- 每个重做日志记录都有唯一的LSN
- LSN单调递增，标识日志的写入顺序
- 用于崩溃恢复和复制同步

1.2 Checkpoint机制

**检查点类型：**

1. **Sharp Checkpoint**：关闭数据库时完全刷新
2. **Fuzzy Checkpoint**：运行时增量刷新
3. **Async Checkpoint**：后台线程定期刷新



##### Undo Log管理

**Undo段管理：**

- 每个回滚段包含1024个Undo槽
- 每个事务占用一个Undo槽
- Undo日志组成版本链，支持MVCC



##### **崩溃恢复流程**

1. **重做阶段(Redo)**：应用Redo Log中的已提交事务
2. **回滚阶段(Undo)**：回滚未提交的事务
3. **前滚恢复**：应用二进制日志（如果配置）
4. **一致性检查**：验证数据页的完整性



### 3 一条 SQL 语句完整执行流程

以 `UPDATE users SET name = ‘Bob’ WHERE id = 1;`为例：

**1 连接与认证：**客户端与 MySQL 服务端建立连接，并进行权限验证。

**2 解析与优化：**服务层对 SQL 进行解析，优化器生成执行计划（决定使用主键索引）。

**3 执行：** 

a. 从 Buffer Pool 中查找 `id=1`所在的页。如果不在，则从磁盘加载。 

b. 在 Buffer Pool 中，**先写 Undo Log**，记录 `name`的旧值。 

c. 然后修改 Buffer Pool 中的页，将 `name`改为 ‘Bob’。该页变为“脏页”。 

d. 执行器将本次修改记录到 **Redo Log Buffer**（内存中的一个区域）。

**4 提交事务：** 

a. 执行 `COMMIT;`时，将 Redo Log Buffer 中的内容**刷入**Redo Log 文件（磁盘）。 

b. 此时，即使在刷脏页前宕机，数据也能恢复。事务提交成功。

**5 后台操作：**InnoDB 的后台线程会在合适的时间将 Buffer Pool 中的脏页刷回磁盘数据文件。



## 二、其他

### 1 聚簇索引 vs 非聚簇索引（二级索引）

**聚簇索引的特点：**

- 数据按聚簇索引键值的顺序物理存储
- 叶子节点包含完整的行数据
- 每个表只能有一个聚簇索引
- 查询通过聚簇索引访问数据最快（无需回表）

**二级索引的特点：**

- 叶子节点存储的是**索引列的值 + 主键值**
- 通过二级索引查询需要"回表"操作
- 一个表可以有多个二级索引
- 包括普通索引、唯一索引、复合索引等

**性能影响**：

聚簇索引的优势

- **查询速度快**：主键查询最快，数据物理上连续存储
- **范围查询高效**：适合主键的范围扫描

- **排序优化**：主键排序几乎无成本

二级索引的考虑

- **回表成本**：二级索引查询需要额外的磁盘I/O
- **覆盖索引**：合理设计可避免回表
- **索引选择性**：高选择性的列适合建索引



### 2 叶子节点是全部放到内存中吗？

​		**不是**。只有当前被访问的叶子节点页才会被加载到内存中。B+Tree的叶子节点是分布在磁盘上的多个页，通过缓冲池机制按需加载。



### 3 如果叶子节点的数据大于内存值会报错吗？

**不会报错**。MySQL使用LRU淘汰算法管理缓冲池：

- **分页加载**：每次只加载需要的16KB页，不是一次性加载所有数据
- **LRU淘汰算法**：当缓冲池满时，自动淘汰最久未使用的页

- 频繁访问的"热数据"保留在内存中
- 不常访问的"冷数据"被淘汰出内存
- 需要时再从磁盘重新加载

**LRU列表管理：**

1. **新页加入**：放入年轻端（占用5/8空间）
2. **频繁访问**：保持在年轻端
3. **访问减少**：逐渐移到老端（占用3/8空间）
4. **需要空间**：淘汰老端最久未使用的页



### 4 点查询与范围查询

1 小范围查询（单个中间节点）

```sql
SELECT * FROM orders WHERE order_id BETWEEN 1000 AND 1100;

执行流程：
1. 根节点 → 判断在中间节点B范围 → 加载中间节点B页
2. 中间节点B → 找到起始叶子节点
3. 沿叶子节点链表扫描15个叶子节点
4. 完成查询，不需要加载中间节点A或C
```

2 大范围查询（跨多个中间节点）

```sql
SELECT * FROM orders WHERE order_id BETWEEN 1000 AND 5000;

执行流程：
1. 根节点 → 判断1000在中间节点B → 加载中间节点B页
2. 中间节点B → 找到起始叶子节点
3. 沿叶子节点链表扫描，直到中间节点B的末尾
4. 加载下一个叶子节点（属于中间节点C范围）
5. 此时需要加载中间节点C页来快速定位？ ❌ 不需要！
6. 直接通过叶子节点链表继续扫描 ✅
```

**重要：** 叶子节点之间的双向链表使得范围查询**不需要回溯到中间节点层**



### 5 叶子节点链表的优势

​		B+Tree叶子节点通过指针连接，这是范围查询高效的关键
范围查询只需要：

1. 找到起始叶子节点（通过中间节点导航）
2. 沿叶子节点链表顺序扫描
3. 不需要再访问中间节点层



### 6 表中的一条数据能大于16KB吗？

**是的，表中的一条数据完全可以大于16KB！**

mysql默认的页大小为 通常16384字节(16KB)。但实际的单行限制比16KB大得多！

当一行数据超过页大小时，InnoDB使用**行溢出（Row Overflow）**机制：

```
正常行存储（< 16KB）：
[页头] [行记录(完整数据)] [页尾]

行溢出存储（> 16KB）：
[页头] [行记录(部分数据+溢出指针)] [页尾]
                    ↓
              [溢出页：剩余数据]
```



### 7 大行的性能考虑

**行溢出机制**：当行数据超过页大小时，InnoDB将大部分数据存储在溢出页中，主页只保留指针

**实际限制**：单行最大受`max_allowed_packet`控制（通常4MB-1GB），远大于16KB

**行格式选择**：

-  `COMPACT`：存储768字节前缀+溢出页
- `DYNAMIC`（5.7.9+默认，推荐）：只存储20字节指针+全部数据在溢出页

**性能影响**：

-  ✅ 大行需要更多的I/O操作（读取多个页）
-  ✅ 更新操作更复杂
-  ✅ 占用更多缓冲池空间



### 8 IN查询

**基本执行**

```sql
-- 示例查询
SELECT * FROM users WHERE id IN (100, 500, 1000);


步骤1: 处理 id=100
        ↓
步骤2: 处理 id=500  
        ↓
步骤3: 处理 id=1000
        ↓
步骤4: 合并结果
```

**小范围IN查询（优化器可能选择范围扫描）**

```sql
-- IN 值连续或接近时，可能优化为范围扫描
SELECT * FROM users WHERE id IN (100, 101, 102, 103);

-- 优化器可能转换为：
SELECT * FROM users WHERE id BETWEEN 100 AND 103;
```

**分散的IN查询（逐个查找）**

```sql
-- 值分散时，通常逐个查找
SELECT * FROM users WHERE id IN (100, 5000, 100000);

-- 执行计划通常是：
EXPLAIN SELECT * FROM users WHERE id IN (100, 5000, 100000);
-- 显示：type=range, but actually multiple single-point lookups
```



### 9 索引查询

**聚簇索引**

```sql
-- 主键IN查询
SELECT * FROM users WHERE id IN (100, 500, 1000);


值1: id=100
根节点 → 中间节点A → 叶子节点X (包含id=100)
     ↓
值2: id=500  
根节点 → 中间节点B → 叶子节点Y (包含id=500)
     ↓
值3: id=1000
根节点 → 中间节点C → 叶子节点Z (包含id=1000)
```

**二级索引（需要回表）**

```sql
-- 二级索引IN查询
SELECT * FROM users WHERE email IN ('a@test.com', 'b@test.com', 'c@test.com');


步骤1: 在email索引找到 'a@test.com' → 获取主键id=100
步骤2: 用主键id=100回表查询完整数据
步骤3: 在email索引找到 'b@test.com' → 获取主键id=500  
步骤4: 用主键id=500回表查询完整数据
步骤5: 在email索引找到 'c@test.com' → 获取主键id=1000
步骤6: 用主键id=1000回表查询完整数据
```



### 10 同时更新和查询同一条行数据时，这两个是同时进行的吗？

​		**答案是：这两个操作可以同时进行，但查询看到的数据内容取决于MySQL的隔离级别和具体的执行时机。**

​		InnoDB使用MVCC来处理并发读写，而不是简单的加锁阻塞。这是实现高并发的关键。

**不同隔离级别的行为差异：**

**场景1：READ-COMMITTED（读已提交）隔离级别**

```sql
-- 会话1（更新事务）
START TRANSACTION;
UPDATE users SET name = 'NewName' WHERE id = 1;
-- 此时尚未COMMIT

-- 会话2（查询事务）  
START TRANSACTION;
SELECT name FROM users WHERE id = 1; -- 此时查询会看到什么？
```

**执行过程：**

1. **更新事务**：给id=1的行加**排他锁(X Lock)**，修改数据，生成Undo Log记录旧值
2. **查询事务**：由于使用READ-COMMITTED，会**读取最新已提交的数据快照**
3. **结果**： 如果查询在更新**提交前**执行：看到的是旧值 'OldName' 。如果查询在更新**提交后**执行：看到的是新值 'NewName'

**场景2：REPEATABLE-READ（可重复读）隔离级别（MySQL默认）**

```sql
-- 会话1
START TRANSACTION;
UPDATE users SET name = 'NewName' WHERE id = 1;

-- 会话2
START TRANSACTION;
SELECT name FROM users WHERE id = 1; -- 第一次查询
-- 会话1 COMMIT后
SELECT name FROM users WHERE id = 1; -- 第二次查询
```

**执行过程：**

1. **查询事务开始时**创建Read View（记录当前活跃事务列表）
2. **无论更新事务是否提交**，查询事务始终看到事务开始时的数据快照
3. **结果**：两次查询都返回相同的旧值 'OldName'



### 11 同时更新和查询同一条行数据时，更新是排它锁，读是共享锁，为什么可以同时进行？

​		**这里有一个关键的概念需要澄清：在MySQL的默认配置下，普通的SELECT查询（非锁定读）实际上并不会加共享锁(S Lock)。**

**核心概念：快照读 vs 当前读**

**快照读（Snapshot Read）- 不加锁**

```sql
-- 这是普通的SELECT查询，使用MVCC机制
SELECT * FROM users WHERE id = 1;  -- 快照读，不加任何锁！
```

**工作原理：**

- 读取事务开始时（或语句开始时，取决于隔离级别）的数据快照
- 通过Undo Log的版本链访问适当版本的数据
- **完全不加锁**，因此不会与更新操作的排他锁冲突

**当前读（Current Read）- 加锁**

```sql
-- 这些是加锁的读取操作
SELECT * FROM users WHERE id = 1 FOR UPDATE;      -- 加排他锁(X Lock)
SELECT * FROM users WHERE id = 1 LOCK IN SHARE MODE; -- 加共享锁(S Lock)
UPDATE users SET name = 'new' WHERE id = 1;       -- 加排他锁(X Lock)  
DELETE FROM users WHERE id = 1;                   -- 加排他锁(X Lock)
```



### 12 MVCC如何实现无锁读取

```
数据版本链示例：
当前版本: [id=1, name='NewName', DB_TRX_ID=200, DB_ROLL_PTR→0x123]
                    ↑
旧版本:   [id=1, name='OldName', DB_TRX_ID=100, DB_ROLL_PTR→NULL]
```

并发执行的详细流程

```sql
-- 时间线演示
-- T1时刻: 会话1开始更新事务
SESSION1> START TRANSACTION;
SESSION1> UPDATE users SET name = 'NewName' WHERE id = 1; -- 对id=1加X锁

-- T2时刻: 会话2执行普通查询（此时更新事务尚未提交）
SESSION2> START TRANSACTION; 
SESSION2> SELECT name FROM users WHERE id = 1; -- 看到什么？
```

**MVCC的工作过程：**

1. **更新事务**：对id=1的行加X锁，修改数据，创建新版本，旧版本存入Undo Log
2. **查询事务**：检查行的事务ID(DB_TRX_ID=200)，发现该事务尚未提交
3. **版本回溯**：通过DB_ROLL_PTR指针找到旧版本(DB_TRX_ID=100)
4. **读取旧版本**：返回旧值'OldName'，完全不需要加锁

**锁兼容性表：**

```
当前锁模式 →   无锁    S锁    X锁
想要加的锁 ↓
无锁（快照读）   ✅     ✅     ✅    ← 这就是关键！
S锁            ✅     ✅     ❌
X锁            ✅     ❌     ❌
```

- **快照读（无锁）** 与任何锁都兼容
- 只有**显示加锁**的读取才会与更新操作的X锁冲突

**隔离级别的影响：**

READ-COMMITTED（读已提交）

```sql
-- 每次查询都读取最新已提交的快照
SESSION1> START TRANSACTION;
SESSION1> UPDATE users SET name = 'B' WHERE id = 1;

SESSION2> START TRANSACTION;
SESSION2> SELECT name FROM users WHERE id = 1; -- 看到A（旧值）

SESSION1> COMMIT;

SESSION2> SELECT name FROM users WHERE id = 1; -- 看到B（新提交的值）
```

REPEATABLE-READ（可重复读，MySQL默认）

```sql
-- 整个事务中读取同一快照
SESSION1> START TRANSACTION;
SESSION1> UPDATE users SET name = 'B' WHERE id = 1;

SESSION2> START TRANSACTION;
SESSION2> SELECT name FROM users WHERE id = 1; -- 看到A

SESSION1> COMMIT;

SESSION2> SELECT name FROM users WHERE id = 1; -- 仍然看到A（一致性视图）
```



