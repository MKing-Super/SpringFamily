# ActiveMQ示例

## 一、ActiveMQ如何产生的

### 产生背景

​		一开始消息中间件的厂商繁多，且各个厂商之间没有统一的规范，这就导致了各消息中间件非常难以整合协作，因此，后来陆续出现了如 **JMS** 和 **AMQP** 这样的**消息队列**规范，提供了统一的标准，而 ActiveMQ 就是完全遵循 JMS 规范开发的消息队列。

> AMQP（Advanced Message Queuing Protocol）是一个开放标准的应用层协议，用于面向消息的中间件。

### JMS规范

#### 基本概念

什么是JMS（Java Message Service）规范？

​		JMS是一个基于Java平台面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。在设计 JMS 时，设计师就计划能够结合现有消息队列的优点，如：

- 不同的消息传送模式或域，例如：点对点消息传送 和 发布/订阅消息传送
- 支持同步和异步消息
- 支持可靠性消息的传输
- 支持常见的消息格式，如：文本、字节、流、对象等

#### JMS体系结构

![](.\images\activemq-01.png)

上面是从百度找的一个图片，下面对其中各个对象分别进行说明：

- ConnectionFactory：**连接工厂**，一般设为单例模式，一旦创建，就一直运行在应用容器内，客户端使用连接工厂创建一个 JMS连接。
- Connection：**JMS连接** 表示JMS客户端和服务器端之间的一个活动的连接。
- Session：**JMS会话** 表示JMS客户与JMS服务器之间的会话状态。JMS会话 建立在JMS连接上，表示客户与服务器之间的一个会话线程。
- Destination：**消息管道**，从生产端流向客户端，包括队列（PTP）,主题（Pub/Sub）。
- Message Producer和Message Consumer：**生产者** 和 **消费者** 对象由Session对象创建，用于发送和接收消息。
- Message：**JMS 消息** 由以下几部分组成：消息头，属性，消息体。
      **消息头**（header）：JMS消息头 包含了许多字段，它们是消息发送后由JMS提供者或消息发送者产生，用来表示消息、设置优先权和失效时间等等，并且为消息确定路由Routing。
      **属性**（property）：由消息发送者产生，用来添加删除消息头以外的附加信息。
      **消息体**（body）：由消息发送者产生，JMS中定义了5种消息体：ByteMessage、MapMessage、ObjectMessage、StreamMessage和TextMessage。

> 网络路由：是指数据包从源地址到目的地址的路径选择过程。



## 二、核心概念与架构

​		ActiveMQ 的基本架构围绕 **Broker（代理）**这个概念展开。Broker 就是 ActiveMQ 的服务端实例，负责接收、路由、存储和转发消息。

### 1 核心角色

- **消息生产者（Producer）**： 创建并发送消息到 Broker 的客户端应用程序。
- **消息消费者（Consumer）**： 从 Broker 接收并处理消息的客户端应用程序。
- **ActiveMQ Broker（代理）**： 消息中间件的核心，充当消息路由的中转站。

### 2 两种主要的消息传递模式

**点对点（Point-to-Point, PTP / Queue）**：

- **队列（Queue）**是目标地址。 
- 一条消息只能被一个消费者消费。即使有多个消费者监听同一个队列，Broker 也会确保一条消息只交付给其中一个。
- 体现了“负载均衡”的思想，适合任务分发场景。

**发布/订阅（Publish/Subscribe, Pub/Sub / Topic）**： 

- **主题（Topic）**是目标地址。 
- 一条消息会被发送给所有订阅了该 Topic 的消费者。 
- 体现了“广播”的思想，适合事件通知场景。

### 3 网络连接与协议

​		客户端（生产者和消费者）需要连接到 Broker 才能进行通信。ActiveMQ 支持多种连接方式，最核心的是使用 **传输连接器（Transport Connector）**。

**协议支持**： ActiveMQ 的强大在于其多协议支持，这意味着不同语言、不同技术的客户端都能与之交互。 

- **OpenWire**： ActiveMQ 自有的高性能二进制协议，是 Java 客户端的默认协议。
- **AMQP**： 高级消息队列协议，一个开放标准，被很多消息系统支持。 
- **MQTT**： 专为物联网设计的轻量级协议。 
- **Stomp**： 简单的文本导向消息协议，适合脚本语言。 
- **WS/S**： WebSocket。

### 4 消息的存储与持久化

为了保证消息的可靠性（如服务器重启后消息不丢失），ActiveMQ 需要将消息持久化到存储介质中。

- **KahaDB（默认）**： 一个专门为 ActiveMQ 设计的持久化解决方案，它基于文件系统和本地事务日志，提供了优异的性能和可靠性。它也是目前版本的推荐选择。
- **JDBC**： 将消息存储到关系型数据库（如 MySQL, PostgreSQL）中。这种方式便于通过数据库工具查看和管理消息，但性能通常不如 KahaDB。
- **内存存储**： 消息只存储在内存中，性能最高，但 Broker 重启后所有消息都会丢失。

### 5 消息的派发机制

Broker 如何将消息发送给消费者是关键环节。

- **异步派发**： 默认方式。Broker 将消息放入一个派发队列，然后立即返回，由另一个线程异步地将消息发送给消费者。这种方式吞吐量高。
- **同步派发**： 在某些情况下（例如，消费者处理速度非常快，或者需要严格的消息顺序），Broker 会等待消费者确认收到上一条消息后，再发送下一条。这会影响吞吐量但能保证顺序。

### 6 消息确认机制

​		为了保证消息被消费者**成功处理**（而不仅仅是成功接收），ActiveMQ 遵循 JMS 规范，提供了消息确认模式。

- **AUTO_ACKNOWLEDGE**： 会话自动确认消息。当消息被成功传递给消费者时，会话即认为消息已被成功处理。
- **CLIENT_ACKNOWLEDGE**： 客户端手动确认。消费者需要调用 `message.acknowledge()`方法来确认消息。这通常用于批处理，可以确认一批消息。
- **DUPS_OK_ACKNOWLEDGE**： 允许重复的确认。它是一种**懒加载（Lazy）**的消息确认模式。在这种模式下，消息会话（Session）会“懒惰地”、批量地向 Broker 确认消息的接收，而不是像其他模式那样积极地、逐条地确认。**最核心的特征是：为了提升性能，它允许消息被重复传递。**

> **什么是幂等性？**
>
> 幂等性是指一个操作执行一次与执行多次的效果是相同的。例如：
>
> - **非幂等操作**： `update account set balance = balance + 100 where id = 1;`（如果执行两次，会加200元）。
> - **幂等操作**： `update account set balance = 200 where id = 1;`（无论执行多少次，余额最终都是200元）。或者，在插入数据库记录前，先根据消息ID查询是否已存在。



## 三、高级特性与原理

### 1 集群与高可用

为了避免单点故障，ActiveMQ 支持集群部署。

**Master-Slave 模式**： 

- **共享存储型 Master-Slave**： 多个 Broker 实例共享一个持久化存储（如共享文件系统或数据库）。只有一个实例（Master）对外提供服务，其他实例（Slave）处于待命状态。当 Master 宕机时，某个 Slave 会接管存储并成为新的 Master。这是最经典的高可用方案。
- **基于 ZooKeeper 的 Replicated LevelDB Store**： 利用 ZooKeeper 来选举 Master，并且每个 Broker 实例都有自己的 LevelDB 存储，数据会在 Master 和 Slave 之间复制。这避免了共享存储的单点故障。

**Broker 网络**： 用于实现跨网络、跨地域的多个 ActiveMQ 集群之间的消息路由和联邦，可以构建一个全球性的消息总线。

### 2 消息过滤

​		ActiveMQ 支持基于 **SQL-92 条件表达式语法**的消息选择器。生产者在发送消息时可以设置消息属性（键值对），消费者在订阅时可以指定一个选择器表达式，只有属性匹配该表达式的消息才会被投递给该消费者。

​		例如：消费者可以设置选择器为 `"stock = 'AAPL' AND price > 200"`，那么它只会收到股票代码为 AAPL 且价格高于 200 的消息。



**简单工作流程总结**：

1. **启动**： ActiveMQ Broker 启动，加载配置，初始化传输连接器和持久化存储。
2. **连接**： 生产者和消费者通过某种协议（如 TCP）连接到 Broker。
3. **发送**： 生产者将消息发送到指定的目的地（Queue 或 Topic）。
4. **存储与路由**： Broker 接收消息，根据消息的持久化设置进行存储，然后根据目的地的类型和配置的路由规则，决定将消息投递给哪些消费者。
5. **消费**： Broker 将消息推送给（或由消费者拉取）在线的消费者。
6. **确认**： 消费者处理完消息后，根据确认模式向 Broker 返回确认。
7. **清理**： Broker 收到确认后，将已成功投递的持久化消息标记为可删除。



## 四、其他

### 1 点对点、发布订阅中消费者都是使用拉取的方式获取消息吗？

​		不完全是。在 ActiveMQ（以及 JMS 规范）中，消费者默认和推荐的方式是 Broker 主动推送，而不是消费者主动拉取。但这**两种方式在技术上都是支持**的。



**为什么推送是默认和高效的？**

1. **低延迟**：消息一到，Broker 就立即推送给消费者，无需等待消费者轮询。
2. **高吞吐量**：异步推送允许 Broker 在消费者处理上一条消息的同时，就发送下一条消息，实现了“流水线”操作，极大地提高了系统吞吐量。
3. **资源高效**：避免了消费者不断轮询（Polling）带来的空转和网络资源浪费。



**两种模式下的推送细节**

**1. 点对点（Queue）的推送**

**负载均衡**：当有多个消费者同时监听同一个 Queue 时，Broker 会采用轮询（Round-Robin）或其他策略，确保每条消息**只推送给其中一个消费者**。这是典型的负载均衡模式。

**预取限制**：这是推送模式中的一个关键优化。消费者在连接时会告诉 Broker 自己的“预取限制”（Prefetch Limit，默认为 1000）。这意味着，Broker 会一次性最多推送（比如）1000  条消息到消费者的本地缓冲区，然后暂停推送，直到消费者处理并确认了部分消息，腾出了缓冲区空间。 

- **优点**：减少了网络往返次数，提高了效率。

- **潜在问题**：如果消费者处理速度慢，可能导致消息在某个消费者上堆积，而其他空闲的消费者却拿不到消息。这时可以调小预取限制（甚至设为1），以实现更公平的负载均衡。

**2. 发布/订阅（Topic）的推送**

- **广播**：对于非持久化主题，Broker 会将消息**同时推送给所有当前在线的订阅者**。
- **持久化订阅**：对于持久化主题，即使订阅者离线，Broker 也会为它保存消息。当该订阅者重新上线时，Broker 会**将积累的消息推送给它**。



**拉取方式**

​		尽管推送是默认和高效的方式，但 JMS 规范也提供了**主动拉取消息**的同步 API，主要用于一些特定场景。

**核心 API：`MessageConsumer.receive()`**

- `receive()`：**阻塞方法**。调用它会一直阻塞当前线程，直到收到一条消息或超时。

- `receive(long timeout)`：**带超时的阻塞方法**。在指定时间内等待消息，超时后返回 `null`。

**拉取方式的特点：**

- **控制权在消费者**：消费者完全控制何时去获取消息，适合需要精确控制处理节奏的场景。
- **同步操作**：线程在 `receive()`调用处被阻塞，效率低下。

- **低效**：如果队列为空，轮询会导致空等，浪费资源。

**拉取方式的使用场景（非常有限）：**

- **简单的测试或示例程序**：代码逻辑简单明了。
- **需要严格按批处理的消息**：例如，消费者每次只拉取一条消息，处理完并提交事务后，再拉取下一条。这能保证每条消息都在一个独立的事务中处理。
- **对实时性要求不高的特定任务**。






















